<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maxwell</title>
  
  <subtitle>site space</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-19T15:01:38.990Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Max well</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Pytorch学习基础——损失函数</title>
    <link href="http://example.com/2022/01/19/Pytorch%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2022/01/19/Pytorch%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</id>
    <published>2022-01-19T14:59:35.191Z</published>
    <updated>2022-01-19T15:01:38.990Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="Pytorch学习基础——损失函数"><a href="#Pytorch学习基础——损失函数" class="headerlink" title="Pytorch学习基础——损失函数"></a>Pytorch学习基础——损失函数</h3><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><ul><li><ul><li><a href="#Pytorch_0">Pytorch学习基础——损失函数</a><ul><li><ul><li>  <a href="#1__5">1. 分类损失</a></li><li><ul><li>  <a href="#11__BCELoss__family_7">1.1 二分类 B C E L o s s   f a m i l y BCELoss \ family BCELossfamily</a></li><li>  <a href="#12__CrossEntropyLoss__family_66">1.2多分类 C r o s s E n t r o p y L o s s   f a m i l y CrossEntropyLoss \ family CrossEntropyLossfamily</a></li></ul></li><li>  <a href="#2_113">2.回归损失</a></li><li><ul><li>  <a href="#21_L1__loss_MAE_115">2.1 L 1   l o s s ( M A E ) L1 \ loss (MAE) L1loss(MAE)</a></li><li>  <a href="#22_L2__loss__161">2.2 L 2   l o s s ( ) L2 \ loss () L2loss()</a></li><li>  <a href="#22_L2__loss__MSE_163">2.2 L 2   l o s s   ( M S E ) L2 \ loss \ (MSE) L2loss(MSE)</a></li></ul></li><li>  <a href="#3one_hot__198">3.one_hot 编码</a></li><li>  <a href="#4_256">4.自定义损失的两种方法</a></li><li><ul><li>  <a href="#41_nnModule_258">4.1 继承自 n n . M o d u l e nn.Module nn.Module</a></li><li>  <a href="#42__297">4.2 自定义损失函数</a></li><li>  <a href="#43__312">4.3 两个常见的自定义损失函数</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p>损失函数的形式化表示： L l o s s = ∑ i = 1 N b c r i t e r i o n ( y ∗ , y ) L_{loss} = \sum_{i=1}^{N_b}criterion(y^{<em>},y) Lloss​=∑i=1Nb​​criterion(y∗,y)， 其中 y ∗ ∈ R B × C y^{</em>}\in \R^{B\times C} y∗∈RB×C为模型预测输出， y ∈ R B × C y\in \R^{B\times C} y∈RB×C为真实标签或标注, B B B为 b a t c h _ s i z e batch\_size batch_size, C C C为全连接层输出，当损失函数对每个 b a t c h batch batch计算损失时，此时有 B = 1 B=1 B=1。根据实际问题的属性，损失函数大致可分类为两类，即分类损失和回归损失。</p><h4 id="1-分类损失"><a href="#1-分类损失" class="headerlink" title="1. 分类损失"></a>1. 分类损失</h4><h5 id="1-1-二分类-B-C-E-L-o-s-s-f-a-m-i-l-y-BCELoss-family-BCELossfamily"><a href="#1-1-二分类-B-C-E-L-o-s-s-f-a-m-i-l-y-BCELoss-family-BCELossfamily" class="headerlink" title="1.1 二分类 B C E L o s s   f a m i l y BCELoss \ family BCELossfamily"></a>1.1 二分类 B C E L o s s   f a m i l y BCELoss \ family BCELossfamily</h5><p>L l o s s ( y ′ , y ) = ∑ i = 1 N b y i log ⁡ ( y i ′ ) L_{loss} (y^{‘},y)= \sum_{i=1}^{N_b}y_i\log(y_{i}^{‘}) Lloss​(y′,y)=i=1∑Nb​​yi​log(yi′​)</p><pre><code>import torchimport torch.nn as nndef tensor_info(tensor):    print(&#39;tensor type: &#123;&#125;&#39;.format(tensor.type()))    print(&#39;tensor value: &#123;&#125;&#39;.format(tensor.data))    print(&#39;tensor shape: &#123;&#125;&#39;.format(tensor.shape))criterion = nn.BCELoss()batchsize = 2num_class = 2y_ = torch.randn(batchsize,num_class)y = torch.empty(batchsize,num_class).random_(num_class)loss = criterion(nn.Sigmoid()(y_), y)tensor_info(y_)tensor_info(y)tensor_info(loss)&quot;&quot;&quot;tensor type: torch.FloatTensortensor value: tensor([[-0.0734,  1.1474],                      [-0.1513, -0.3409]])                      tensor shape: torch.Size([2, 2])tensor type: torch.FloatTensortensor value: tensor([[0., 1.],                      [0., 0.]])                      tensor shape: torch.Size([2, 2])tensor type: torch.FloatTensortensor value: 0.5225892663002014tensor shape: torch.Size([])&quot;&quot;&quot;</code></pre><p><strong>note</strong>:</p><ol><li>B C E L o s s BCELoss BCELoss用于二分类问题，tensor的类型为 t o r c h . F l o a t T e n s o r torch.FloatTensor torch.FloatTensor,模型的输出为 s i g m o i d sigmoid sigmoid类型，即要求输出为 [ 0 , 1 ] [0,1] [0,1];</li><li>B C E L o s s BCELoss BCELoss较 C r o s s E n t r o p y L o s s CrossEntropyLoss CrossEntropyLoss训练更稳定；</li><li>当二分类类别不平衡时可以考虑 B C E W i t h L o g i t s L o s s BCEWithLogitsLoss BCEWithLogitsLoss,此时的模型输出为 l o g i t s logits logits形式，同时需要传入 w e i g h t weight weight权重参数；<pre><code> w_0 = 1 w_1 = 5 class_weights = Variable(torch.FloatTensor[w_0, w_1]) criterion = nn.BCEWithLogitsLoss(class_weights) ... loss = criterion(y_, y) </code></pre></li></ol><h5 id="1-2多分类-C-r-o-s-s-E-n-t-r-o-p-y-L-o-s-s-f-a-m-i-l-y-CrossEntropyLoss-family-CrossEntropyLossfamily"><a href="#1-2多分类-C-r-o-s-s-E-n-t-r-o-p-y-L-o-s-s-f-a-m-i-l-y-CrossEntropyLoss-family-CrossEntropyLossfamily" class="headerlink" title="1.2多分类 C r o s s E n t r o p y L o s s   f a m i l y CrossEntropyLoss \ family CrossEntropyLossfamily"></a>1.2多分类 C r o s s E n t r o p y L o s s   f a m i l y CrossEntropyLoss \ family CrossEntropyLossfamily</h5><p>L l o s s ( y ′ , y ) = − log ⁡ ( exp ⁡ ( y [ y ] ′ ) ∑ j exp ⁡ [ y [ j ] ′ ] ) = − y [ y ] ′ + l o g ( ∑ j exp ⁡ ( y [ j ] ′ ) L_{loss} (y^{‘},y)= -\log(\dfrac{\exp(y^{‘}<em>{[y]})}{\sum</em>{j}\exp[y^{‘}<em>{[j]}]}) = -y^{‘}</em>{[y]}+log(\sum_{j}\exp(y^{‘}_{[j]}) Lloss​(y′,y)=−log(∑j​exp[y[j]′​]exp(y[y]′​)​)=−y[y]′​+log(j∑​exp(y[j]′​)</p><pre><code>criterion = nn.CrossEntropyLoss()batchsize = 2num_class = 3y_ = torch.randn(batchsize,num_class)y = torch.empty(batchsize, dtype=torch.long).random_(num_class)loss = criterion(nn.Softmax()(y_), y)tensor_info(y_)tensor_info(y)tensor_info(loss)&quot;&quot;&quot;tensor type: torch.FloatTensortensor value: tensor([[ 0.9964,  0.7243, -1.0832],                      [ 1.2502,  0.9600, -0.1909]])tensor shape: torch.Size([2, 3])tensor type: torch.LongTensortensor value: tensor([2, 0])tensor shape: torch.Size([2])tensor type: torch.FloatTensortensor value: 1.1623895168304443tensor shape: torch.Size([])&quot;&quot;&quot;</code></pre><p><strong>note</strong>:</p><ol><li>C r o s s E n t r o p y L o s s CrossEntropyLoss CrossEntropyLoss既可以用于二分类问题也可以用于多分类，target tensor的类型为 t o r c h . L o n g T e n s o r torch.LongTensor torch.LongTensor，维度为 y ∈ R B y\in \R^{B} y∈RB,代码自动将输出转换为 o n e _ h o t one\_hot one_hot编码,模型的输出为 s o f t m a t softmat softmat类型，即要求输出为多维 [ 0 , 1 ] [0,1] [0,1];</li><li>由于 B C E L o s s BCELoss BCELoss较 C r o s s E n t r o p y L o s s CrossEntropyLoss CrossEntropyLoss训练更稳定，因此二分类多使用前者，而多分类时只能使用后者；</li><li>多类别数据不平衡时，可以考虑多分类负对数损失函数 n n . N L L L o s s nn.NLLLoss nn.NLLLoss；<pre><code> criterion = nn.NLLLoss() ... loss = criterion(nn.LogSoftmax(dim=1)(y_), y) </code></pre></li></ol><h4 id="2-回归损失"><a href="#2-回归损失" class="headerlink" title="2.回归损失"></a>2.回归损失</h4><h5 id="2-1-L-1-l-o-s-s-M-A-E-L1-loss-MAE-L1loss-MAE"><a href="#2-1-L-1-l-o-s-s-M-A-E-L1-loss-MAE-L1loss-MAE" class="headerlink" title="2.1 L 1   l o s s ( M A E ) L1 \ loss (MAE) L1loss(MAE)"></a>2.1 L 1   l o s s ( M A E ) L1 \ loss (MAE) L1loss(MAE)</h5><p>L l o s s ( y ′ , y ) = ∣ y − y ′ ∣ L_{loss} (y^{‘},y)= |y-y^{‘}| Lloss​(y′,y)=∣y−y′∣</p><pre><code>criterion = nn.L1Loss()batchsize = 2data_dim = 5y_ = torch.randn(batchsize,data_dim)y = torch.randn(batchsize, data_dim)loss = criterion(y_, y)tensor_info(y_)tensor_info(y)tensor_info(loss)&quot;&quot;&quot;tensor type: torch.FloatTensortensor value: tensor([[-0.8535, -0.3021,  0.2806,  0.6997, -0.3428],                      [ 1.0466, -0.7761,  1.5299,  1.8677,  0.3375]])tensor shape: torch.Size([2, 5])tensor type: torch.FloatTensortensor value: tensor([[ 0.4172,  0.3862,  1.9460,  0.3330, -0.6183],                      [ 0.4837, -0.8353,  0.4653, -0.3128,  1.7366]])tensor shape: torch.Size([2, 5])tensor type: torch.FloatTensortensor value: 0.953281581401825tensor shape: torch.Size([])&quot;&quot;&quot;</code></pre><p><strong>note</strong>:</p><ol><li>L 1   l o s s L1 \ loss L1loss的输入和输出维度相同；</li><li>L 1   l o s s L1 \ loss L1loss在零点处不平滑，相应地使用 L 1 L1 L1正则容易产生稀疏特征； L 2   l o s s L2 \ loss L2loss对离散点比较敏感，使用梯度下降时可能导致梯度爆炸；</li><li>使用 n n . S m o o t h L 1 L o s s nn.SmoothL1Loss nn.SmoothL1Loss可以在$L1 \ loss 和 和 和L2 \ loss 中 折 中 ， 其 表 达 式 为 ： 中折中，其表达式为： 中折中，其表达式为：L_{loss}(y^{’},y) = \begin{cases} 0.5(y’ -y )^2 \ \ \ \ \ \ \ if \ |y’-y|&lt;1 \ |y’-y|-0.5\ \ \ \ if \ otherwise \end{cases} $<pre><code> criterion = nn.SmoothL1Loss() </code></pre></li></ol><h5 id="2-2-L-2-l-o-s-s-L2-loss-L2loss"><a href="#2-2-L-2-l-o-s-s-L2-loss-L2loss" class="headerlink" title="2.2 L 2   l o s s ( ) L2 \ loss () L2loss()"></a>2.2 L 2   l o s s ( ) L2 \ loss () L2loss()</h5><h5 id="2-2-L-2-l-o-s-s-M-S-E-L2-loss-MSE-L2loss-MSE"><a href="#2-2-L-2-l-o-s-s-M-S-E-L2-loss-MSE-L2loss-MSE" class="headerlink" title="2.2 L 2   l o s s   ( M S E ) L2 \ loss \ (MSE) L2loss(MSE)"></a>2.2 L 2   l o s s   ( M S E ) L2 \ loss \ (MSE) L2loss(MSE)</h5><p>L l o s s ( y ′ , y ) = ( y ′ − y ) 2 L_{loss}(y^{‘}, y) = (y^{‘}-y)^2 Lloss​(y′,y)=(y′−y)2</p><pre><code>criterion = nn.MSELoss()batchsize = 2data_dim = 5y_ = torch.randn(batchsize,data_dim)y = torch.randn(batchsize, data_dim)loss = criterion(y_, y)tensor_info(y_)tensor_info(y)tensor_info(loss)&quot;&quot;&quot;tensor type: torch.FloatTensortensor value: tensor([[-0.9645, -1.3637, -0.3499,  0.1778,  1.4501],                      [ 0.0399, -0.7981,  0.2331, -0.8327, -0.1414]])tensor shape: torch.Size([2, 5])tensor type: torch.FloatTensortensor value: tensor([[ 0.6230,  0.6931,  0.0585, -0.1514, -1.6614],                      [-0.8120, -0.3299, -0.0762, -1.5901,  1.2696]])tensor shape: torch.Size([2, 5])tensor type: torch.FloatTensortensor value: 2.0312931537628174tensor shape: torch.Size([])&quot;&quot;&quot;</code></pre><h4 id="3-one-hot-编码"><a href="#3-one-hot-编码" class="headerlink" title="3.one_hot 编码"></a>3.one_hot 编码</h4><p>当我们想在一个含有 C r o s s E n t r o p y L o s s CrossEntropyLoss CrossEntropyLoss中增加新的损失函数时，需要对模型的输出进行 o n e _ h o t one\_hot one_hot编码，从而能与其他损失联合使用，进而设计自己的损失函数，为自定义损失函数做铺垫。</p><p>一个高效简洁的 o n e _ h o t one\_hot one_hot编码转换如下：</p><pre><code>def tensor_info(tensor):    print(&#39;tensor type: &#123;&#125;&#39;.format(tensor.type()))    print(&#39;tensor value: &#123;&#125;&#39;.format(tensor.data))    print(&#39;tensor shape: &#123;&#125;&#39;.format(tensor.shape))def make_one_hot(label, classes):    label = label.unsqueeze(dim=1)    tensor_info(label)    tensor = torch.zeros(label.size()[0], classes,                          label.size()[2], label.size()[3]).scatter_(1, label, 1)    tensor_info(tensor)class_num = 2batch_size = 2label = torch.LongTensor(batch_size, 3, 3).random_() % class_numtensor = make_one_hot(label, class_num)print(tensor)&quot;&quot;&quot;tensor type: torch.LongTensortensor value: tensor([[[[1, 0, 0],                          [0, 1, 0],                          [1, 0, 1]]],                    [[[0, 0, 0],                          [0, 0, 0],                          [0, 1, 1]]]])tensor shape: torch.Size([2, 1, 3, 3])tensor type: torch.FloatTensortensor value: tensor([[[[0., 1., 1.],                          [1., 0., 1.],                          [0., 1., 0.]],                         [[1., 0., 0.],                          [0., 1., 0.],                          [1., 0., 1.]]],                        [[[1., 1., 1.],                          [1., 1., 1.],                          [1., 0., 0.]],                         [[0., 0., 0.],                          [0., 0., 0.],                          [0., 1., 1.]]]])tensor shape: torch.Size([2, 2, 3, 3])&quot;&quot;&quot;</code></pre><p><strong>note</strong>:</p><ol><li> 上述例子多用于分割图像标注的one_hot编码，一般地，标注的 G r o u n d T r u t h GroundTruth GroundTruth维度为 y ∈ R B × H × W y\in \R^{B \times H\times W} y∈RB×H×W预测的输出为 y ′ ∈ R B × C × H × W y ^{‘}\in \R^{B\times C \times H \times W} y′∈RB×C×H×W，因此需要对 y y y进行 o n e _ h o t one\_hot one_hot编码;</li></ol><h4 id="4-自定义损失的两种方法"><a href="#4-自定义损失的两种方法" class="headerlink" title="4.自定义损失的两种方法"></a>4.自定义损失的两种方法</h4><h5 id="4-1-继承自-n-n-M-o-d-u-l-e-nn-Module-nn-Module"><a href="#4-1-继承自-n-n-M-o-d-u-l-e-nn-Module-nn-Module" class="headerlink" title="4.1 继承自 n n . M o d u l e nn.Module nn.Module"></a>4.1 继承自 n n . M o d u l e nn.Module nn.Module</h5><pre><code>class MyLoss(nn.Module):    def __init__(self):        super().__init__()        def forward(self, input, target):        return torch.mean(torch.pow(input-target, 2))criterion = MyLoss()batchsize = 2data_dim = 5y_ = torch.randn(batchsize,data_dim)y = torch.randn(batchsize, data_dim)loss = criterion(y_, y)tensor_info(y_)tensor_info(y)tensor_info(loss)&quot;&quot;&quot;tensor type: torch.FloatTensortensor value: tensor([[-1.0173,  0.4739, -0.7022, -1.2392, -0.9483],                      [-0.8169,  1.3850, -0.5899, -0.1689, -0.6612]])tensor shape: torch.Size([2, 5])tensor type: torch.FloatTensortensor value: tensor([[ 0.6348, -0.9740,  1.2326,  0.5315, -1.0824],                      [-0.8435,  0.6862,  0.3101, -0.1409,  0.8937]])tensor shape: torch.Size([2, 5])tensor type: torch.FloatTensortensor value: 1.543942928314209tensor shape: torch.Size([])&quot;&quot;&quot;</code></pre><h5 id="4-2-自定义损失函数"><a href="#4-2-自定义损失函数" class="headerlink" title="4.2 自定义损失函数"></a>4.2 自定义损失函数</h5><pre><code>def myLoss(input, target):    return torch.mean(torch.pow(input-target, 2))...loss = myLoss(y_, y)...</code></pre><p><strong>note</strong>:</p><ol><li> 继承自 n n . M o d u l e nn.Module nn.Module类的损失损失函数需要重写 f o r w a r d forward forward方法，定义相关的 t o r c h torch torch运算，设计相对灵活；使用自定义的损失函数相当于间接使用 t o r c h torch torch的损失函数，不需要维护 f o r w a r d forward forward方法，使用时相当于函数调用；</li><li> 损失函数在进行梯度回传时必然要使用 l o s s . b a c k w a r d loss.backward loss.backward方法，上述两种自定义的损失函数都支持该方法，本质上都是间接调用的 t o r c h torch torch的损失函数；</li></ol><h5 id="4-3-两个常见的自定义损失函数"><a href="#4-3-两个常见的自定义损失函数" class="headerlink" title="4.3 两个常见的自定义损失函数"></a>4.3 两个常见的自定义损失函数</h5><p>F o c a l L o s s FocalLoss FocalLoss<br>F L ( p t ) = − ( 1 − p y ) γ l o g ( p t ) FL(p_t)=-(1-p_y)^{\gamma}log(p_t) FL(pt​)=−(1−py​)γlog(pt​)</p><pre><code>class FocalLoss(nn.Module):    def __init__(self, gamma=2, alpha=None, ignore_index=255, size_average=True):        super(FocalLoss, self).__init__()        self.gamma = gamma        self.size_average = size_average        self.CE_loss = nn.CrossEntropyLoss(reduce=False,                                            ignore_index=ignore_index, weight=alpha)    def forward(self, output, target):        logpt = self.CE_loss(output, target)        pt = torch.exp(-logpt)        loss = ((1-pt)**self.gamma) * logpt        if self.size_average:            return loss.mean()        return loss.sum()criterion = FocalLoss()batchsize = 2data_dim = 5y_ = torch.randn(batchsize,data_dim)y = torch.empty(batchsize,dtype=torch.long).random_(data_dim)loss = criterion(nn.Softmax()(y_), y)tensor_info(y_)tensor_info(y)tensor_info(loss)&quot;&quot;&quot;tensor type: torch.FloatTensortensor value: tensor([[ 0.1728,  1.1785,  0.2764, -0.3511,  0.4180],                      [ 0.3613,  0.7521,  1.2390,  2.0650, -0.6268]])tensor shape: torch.Size([2, 5])tensor type: torch.LongTensortensor value: tensor([2, 2])tensor shape: torch.Size([2])tensor type: torch.FloatTensortensor value: 1.0486319065093994tensor shape: torch.Size([])&quot;&quot;&quot;</code></pre><p>D I C E   L o s s DICE\ Loss DICELoss<br>L l o s s ( y ′ , y ) = 1 − 2 × ∣   y ′ ⋂ y   ∣ ∣ y ′ ∣ + ∣ y ∣ L_{loss}(y’, y) = 1 - 2\times\dfrac{|\ y’\bigcap y\ |}{|y’|+|y|} Lloss​(y′,y)=1−2×∣y′∣+∣y∣∣y′⋂y∣​</p><pre><code>class DiceLoss(nn.Module):    def __init__(self, smooth=1., ignore_index=255):        super(DiceLoss, self).__init__()        self.ignore_index = ignore_index        self.smooth = smooth    def forward(self, output, target):        if self.ignore_index not in range(target.min(), target.max()):            if (target == self.ignore_index).sum() &gt; 0:                target[target == self.ignore_index] = target.min()        target = make_one_hot(target, classes=output.size()[1])        output = F.softmax(output, dim=1)        output_flat = output.contiguous().view(-1)        target_flat = target.contiguous().view(-1)        intersection = (output_flat * target_flat).sum()        loss = 1 - ((2. * intersection + self.smooth) /                    (output_flat.sum() + target_flat.sum() + self.smooth))        return losscriterion = DiceLoss()batchsize = 2data_dim = 5y_ = torch.randn(batchsize,data_dim, 3, 3)y = torch.empty(batchsize,3, 3, dtype=torch.long).random_(data_dim)loss = criterion(y_, y)tensor_info(y_)tensor_info(y)tensor_info(loss)&quot;&quot;&quot;tensor type: torch.LongTensortensor value: tensor([[[[0, 3, 1],          [0, 2, 2],          [1, 0, 1]]],        [[[2, 1, 2],          [3, 3, 2],          [1, 3, 4]]]])tensor shape: torch.Size([2, 1, 3, 3])tensor type: torch.FloatTensortensor value: tensor([[[[1., 0., 0.],                      [1., 0., 0.],                      [0., 1., 0.]],                     [[0., 0., 1.],                      [0., 0., 0.],                      [1., 0., 1.]],                     [[0., 0., 0.],                      [0., 1., 1.],                      [0., 0., 0.]],                     [[0., 1., 0.],                      [0., 0., 0.],                      [0., 0., 0.]],                     [[0., 0., 0.],                      [0., 0., 0.],                      [0., 0., 0.]]],                    [[[0., 0., 0.],                      [0., 0., 0.],                      [0., 0., 0.]],                     [[0., 1., 0.],                      [0., 0., 0.],                      [1., 0., 0.]],                     [[1., 0., 1.],                      [0., 0., 1.],                      [0., 0., 0.]],                     [[0., 0., 0.],                      [1., 1., 0.],                      [0., 1., 0.]],                     [[0., 0., 0.],                      [0., 0., 0.],                      [0., 0., 1.]]]])tensor shape: torch.Size([2, 5, 3, 3])tensor type: torch.FloatTensortensor value: tensor([[[[ 0.2699,  2.0570,  0.3527],                      [ 0.1577, -0.4064,  0.1343],                      [ 1.5966,  1.7491,  1.0151]],                     [[-0.8926,  0.1622,  1.9066],                      [ 0.5218,  0.4823, -1.1344],                      [-1.0118, -0.8615, -2.1888]],                     [[-0.3432, -0.3939,  0.1995],                      [-0.1927,  0.1906, -0.9791],                      [-0.7473, -1.4993,  0.3817]],                     [[ 1.9844, -0.3772,  0.0379],                      [-0.3522,  0.3117,  3.4582],                      [ 0.1093, -1.1035,  1.7196]],                     [[-0.3047, -0.0412,  0.4407],                      [ 0.1961,  0.7687,  0.2264],                      [-0.7968, -3.2159,  1.1114]]],                    [[[ 0.2529, -0.2005,  1.4892],                      [-0.6280, -0.5346, -0.8372],                      [ 2.1497, -0.9360,  0.4647]],                     [[ 0.1600, -0.4615, -0.0581],                      [-0.8772, -2.2099, -0.4701],                      [-0.0854, -0.6858,  1.1420]],                     [[-0.5037, -1.4045,  0.3457],                      [ 0.4000,  0.8670,  0.2310],                      [ 0.1687,  2.2899,  1.3715]],                     [[ 0.6839,  0.0109, -1.9138],                      [-0.9788, -0.9355,  0.8609],                      [ 1.4093, -0.5079,  0.1082]],                     [[ 0.8306, -0.9631, -0.8329],                      [-0.0351, -1.1003,  0.2656],                      [-1.8068, -0.5764, -1.0488]]]])tensor shape: torch.Size([2, 5, 3, 3])tensor type: torch.LongTensortensor value: tensor([[[0, 3, 1],         [0, 2, 2],         [1, 0, 1]],        [[2, 1, 2],         [3, 3, 2],         [1, 3, 4]]])tensor shape: torch.Size([2, 3, 3])tensor type: torch.FloatTensortensor value: 0.8061555624008179tensor shape: torch.Size([])&quot;&quot;&quot;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;Pytorch学习基础——损失函数&quot;&gt;&lt;a href=&quot;#Pytorch学习基础——损失函数&quot; class=&quot;headerlink&quot; title=&quot;Pytorch学习基础——损失函数&quot;&gt;&lt;/a&gt;Pytorch学习基</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>图像读取库合集——cv2, PIL, skimage与numpy, pytorch(ToPILimage)</title>
    <link href="http://example.com/2022/01/19/%E5%9B%BE%E5%83%8F%E8%AF%BB%E5%8F%96%E5%BA%93%E5%90%88%E9%9B%86%E2%80%94%E2%80%94cv2,%20PIL,%20skimage%E4%B8%8Enumpy,%20pytorch(ToPILimage)/"/>
    <id>http://example.com/2022/01/19/%E5%9B%BE%E5%83%8F%E8%AF%BB%E5%8F%96%E5%BA%93%E5%90%88%E9%9B%86%E2%80%94%E2%80%94cv2,%20PIL,%20skimage%E4%B8%8Enumpy,%20pytorch(ToPILimage)/</id>
    <published>2022-01-19T14:59:34.855Z</published>
    <updated>2022-01-19T15:01:38.294Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="图像读取库合集——cv2-PIL-skimage与numpy-pytorch-ToPILimage"><a href="#图像读取库合集——cv2-PIL-skimage与numpy-pytorch-ToPILimage" class="headerlink" title="图像读取库合集——cv2, PIL, skimage与numpy, pytorch(ToPILimage)"></a>图像读取库合集——cv2, PIL, skimage与numpy, pytorch(ToPILimage)</h3><h4 id="1-图像读取与属性"><a href="#1-图像读取与属性" class="headerlink" title="1 图像读取与属性"></a>1 图像读取与属性</h4><h5 id="1-1-PIL与numpy间的相互访问"><a href="#1-1-PIL与numpy间的相互访问" class="headerlink" title="1.1 PIL与numpy间的相互访问"></a>1.1 PIL与numpy间的相互访问</h5><pre><code>import numpy as npfrom PIL import Image#read a image with 3 channels, 500x889 pixelsimg_pil =  Image.open(&#39;./test.png&#39;)#show a imageimg_pil.show()#get image imfoprint(img_pil)#get the pixel value in PIL formatprint(img_pil.getpixel((0,0))) #covert PIL to numpyimg_np = np.array(img_pil)print(img_np.shape)#get the pixel value in numpy formatprint(img_np[0,0])#convert numpy to PILimg_pil = Image.fromarray(img_np)print(img_pil)&quot;&quot;&quot;&lt;PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=500x889 at 0x193331AD240&gt;(219, 210, 193)(889, 500, 3)[219 210 193]&lt;PIL.Image.Image image mode=RGB size=500x889 at 0x1933330ADA0&gt;&quot;&quot;&quot;</code></pre><p>n o t e note note：</p><ol><li> PIL库读取图像的三通道顺序为RGB，读取图像的宽度( w i d t h width width)和高度( h e i g h t height height)与原始图像一致;</li><li> PIL库与 n u m p y numpy numpy的转化存在细微的差别： n u m p y . a r r a y ( ) numpy.array() numpy.array()会改变PIL对象的宽度和高度信息， I m a g e . f r o m a r r a y ( ) Image.fromarray() Image.fromarray()会重新调整回原始状态；</li><li> PIL访问某一位置的像素值时调用 i m g _ p i l . g e t p i x e l ( ( x , y ) ) img\_pil.getpixel((x,y)) img_pil.getpixel((x,y)), n u m p y numpy numpy为矩阵形式，直接访问 i n d e x index index, i m g _ n p [ x , y ] img\_np[x,y] img_np[x,y]；</li></ol><h5 id="1-2-cv2与numpy间的相互访问"><a href="#1-2-cv2与numpy间的相互访问" class="headerlink" title="1.2 cv2与numpy间的相互访问"></a>1.2 cv2与numpy间的相互访问</h5><pre><code>import numpy as npimport cv2#read a image with 3 channels, 500x889 pixelsimg_cv = cv2.imread(&#39;./test.png&#39;)#show a imagecv2.imshow(&#39;img&#39;, img_cv)#get image imfoprint(img_cv.shape)#get the pixel value in cv2 formatprint(img_cv[0,0]) #covert cv2 to numpyimg_np = np.array(img_cv)print(img_np.shape)#get the pixel value in numpy formatprint(img_np[0,0])#convert numpy to cv2(not necessary)cv2.imshow(&#39;img_np&#39;, img_np)cv2.waitKey(0)&quot;&quot;&quot;(889, 500, 3)[193 210 219](889, 500, 3)[193 210 219]&quot;&quot;&quot;</code></pre><p>n o t e note note:</p><ol><li> cv2读取图像的三通道顺序为GBR, 图像的宽度信息和高度信息发生调整；</li><li> cv2访问元素和 n u m p y numpy numpy的方式相同，通过 i n d e x index index直接访问；</li><li> cv2可以直接打开 n u m p y numpy numpy数组( u i n t 8 uint8 uint8);</li><li> 为避免cv2闪退，通常加上 c v 2. w a i t K e y ( ) cv2.waitKey() cv2.waitKey()等待键入才退出;</li></ol><h5 id="1-3-skimg与numpy间的相互访问"><a href="#1-3-skimg与numpy间的相互访问" class="headerlink" title="1.3 skimg与numpy间的相互访问"></a>1.3 skimg与numpy间的相互访问</h5><pre><code>import numpy as npfrom skimage import io, transformimport matplotlib.pyplot as plt#read a image with 3 channels, 500x889 pixelsimg_sk = io.imread(&#39;./test.png&#39;)#get image infoprint(img_sk.shape)io.imshow(img_sk)#get the pixel value in skimage formatprint(img_sk[0,0])#covert skimage to numpyimg_np = np.array(img_sk)print(img_np.shape)#get the pixel value in numpy formatprint(img_np[0,0])#convert numpy to skimgio.imshow(img_np)plt.show()&quot;&quot;&quot;(889, 500, 3)[219 210 193](889, 500, 3)[219 210 193]&quot;&quot;&quot;</code></pre><p>n o t e note note:</p><ol><li> s k i m a g e skimage skimage库和 c v 2 cv2 cv2比较相似，可以看到结果输出也基本相同，和 n u m p y numpy numpy的转化也比较方便；</li><li> s k i m a g e skimage skimage库无法直接打开图像，需要借助 m a t p l o t l i b . p y p l o t matplotlib.pyplot matplotlib.pyplot，因此 s k i m a g e skimage skimage通常和 p y p l o t pyplot pyplot合并使用用于过程可视化，可以方便画图、画表格；</li></ol><p><strong>综上而言</strong>，PIL库尽可能保持了原始输入的信息，使用方便快捷，此外，PIL库通常还可以与imageio库相互结合做图像预处理；c v 2 v2 v2将图像转化为数组便于对图像的进一步处理； s k i m a g e skimage skimage和 m a t p l l t l i b matplltlib matplltlib相互结合，做图像对比更加方便；</p><h4 id="2-Pytorch读取图像"><a href="#2-Pytorch读取图像" class="headerlink" title="2 Pytorch读取图像"></a>2 Pytorch读取图像</h4><pre><code>torch.utils.data.DataLoader(dataset, batch_size=batch_size,                                  shuffle=False, num_workers=8, drop_last=False)</code></pre><p>调用 P y t o r c h Pytorch Pytorch的 D a t a L o a d e r DataLoader DataLoader时需要加载 d a t a s e t dataset dataset，此处的 d a t a s e t dataset dataset为自定义的数据，用于输出图像和对应的标签信息，同时对图像做数据增强，此时的数据类型为PIL对象，此处以Standford_car为例（代码来源：<a href="https://github.com/ZF1044404254/MMAL-Net/blob/master/datasets/dataset.py">sourcecode</a>）：</p><pre><code>class STANFORD_CAR():    def __init__(self, input_size, root, is_train=True, data_len=None):        self.input_size = input_size        self.root = root        self.is_train = is_train        train_img_path = os.path.join(self.root, &#39;cars_train&#39;)        test_img_path = os.path.join(self.root, &#39;cars_test&#39;)        train_label_file = open(os.path.join(self.root, &#39;train.txt&#39;))        test_label_file = open(os.path.join(self.root, &#39;test.txt&#39;))        train_img_label = []        test_img_label = []        for line in train_label_file:            train_img_label.append([os.path.join(train_img_path,                                                 line[:-1].split(&#39; &#39;)[0]),                                             int(line[:-1].split(&#39; &#39;)[1])-1])        for line in test_label_file:            test_img_label.append([os.path.join(test_img_path,                                                line[:-1].split(&#39; &#39;)[0]),                                                         int(line[:-1].split(&#39; &#39;)[1])-1])        self.train_img_label = train_img_label[:data_len]        self.test_img_label = test_img_label[:data_len]    def __getitem__(self, index):        if self.is_train:            img, target = imageio.imread(self.train_img_label[index][0]),                                                self.train_img_label[index][1]            if len(img.shape) == 2:                img = np.stack([img] * 3, 2)            img = Image.fromarray(img, mode=&#39;RGB&#39;)            img = transforms.Resize((self.input_size,                                      self.input_size), Image.BILINEAR)(img)            # img = transforms.RandomResizedCrop(size=self.input_size,                                    #scale=(0.4, 0.75),ratio=(0.5,1.5))(img)#            # img = transforms.RandomCrop(self.input_size)(img)            img = transforms.RandomHorizontalFlip()(img)            img = transforms.ColorJitter(brightness=0.2, contrast=0.2)(img)            img = transforms.ToTensor()(img)            img = transforms.Normalize([0.485, 0.456, 0.406],                                        [0.229, 0.224, 0.225])(img)        else:            img, target = imageio.imread(self.test_img_label[index][0]),                                                 self.test_img_label[index][1]            if len(img.shape) == 2:                img = np.stack([img] * 3, 2)            img = Image.fromarray(img, mode=&#39;RGB&#39;)            img = transforms.Resize((self.input_size,                                      self.input_size), Image.BILINEAR)(img)            # img = transforms.CenterCrop(self.input_size)(img)            img = transforms.ToTensor()(img)            img = transforms.Normalize([0.485, 0.456, 0.406],                                           [0.229, 0.224, 0.225])(img)        return img, target    def __len__(self):        if self.is_train:            return len(self.train_img_label)        else:            return len(self.test_img_label)</code></pre><p>此段代码同时使用了PIL库， n u m p y numpy numpy库，以及相应的 i m a g e i o imageio imageio库进行相应的图像增强。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;图像读取库合集——cv2-PIL-skimage与numpy-pytorch-ToPILimage&quot;&gt;&lt;a href=&quot;#图像读取库合集——cv2-PIL-skimage与numpy-pytorch-ToPILim</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指OFFER系列之20----数值字符串</title>
    <link href="http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B20----%E6%95%B0%E5%80%BC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B20----%E6%95%B0%E5%80%BC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-01-19T14:59:34.511Z</published>
    <updated>2022-01-19T15:01:37.874Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="剑指OFFER"><a href="#剑指OFFER" class="headerlink" title="剑指OFFER"></a>剑指OFFER</h3><blockquote><p>题目描述：设计一个函数判断是否表示数值(包含整数和小数)。如“+100”， “5e2”，“-123”， “3.146”，“-1E-16”等。</p></blockquote><pre><code>class Solution&#123;    int i;public:    bool parseB(string&amp; s)&#123;        int temp = i;        while(i &lt; s.size() &amp;&amp; s[i] &gt;= &#39;0&#39; &amp;&amp; s[i] &lt;= &#39;9&#39;)&#123;            i++;        &#125;        return i &gt; temp;    &#125;    bool parseAndC(string&amp; s)&#123;        if(s[i] == &#39;+&#39; || s[i] == &#39;-&#39;)&#123;            i++;        &#125;        return parseB(s);    &#125;    bool isNumeric(string&amp; s)&#123;        if(s.size() == 0)&#123;            return false;        &#125;        i = 0;        bool flag = parseAndC(s);        if(s[i] == &#39;.&#39;)&#123;            i++;            flag = flag || parseB(s);        &#125;        if(s[i] == &#39;e&#39; || s[i] == &#39;E&#39;)&#123;            i++;            flag = flag &amp;&amp; parseAndC(s);        &#125;        return flag;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;剑指OFFER&quot;&gt;&lt;a href=&quot;#剑指OFFER&quot; class=&quot;headerlink&quot; title=&quot;剑指OFFER&quot;&gt;&lt;/a&gt;剑指OFFER&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：设计一个函数判</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指OFFER系列之17----打印n位整数</title>
    <link href="http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B17----%E6%89%93%E5%8D%B0n%E4%BD%8D%E6%95%B4%E6%95%B0/"/>
    <id>http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B17----%E6%89%93%E5%8D%B0n%E4%BD%8D%E6%95%B4%E6%95%B0/</id>
    <published>2022-01-19T14:59:34.399Z</published>
    <updated>2022-01-19T15:01:37.874Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="剑指OFFER"><a href="#剑指OFFER" class="headerlink" title="剑指OFFER"></a>剑指OFFER</h3><blockquote><p>题目描述：输入正整数n,按顺序打印1~n位最大整数。比如输入3，则打印出1,2，3一直到最大的3位整数999。</p></blockquote><pre><code>void printNum(string s)&#123;    int i = 0;    while(s[i] == &#39;0&#39; &amp;&amp; i &lt; s.size())&#123;        i++;    &#125;    if(i &lt; s.size())&#123;        cout &lt;&lt; stoi(s.substr(i)) &lt;&lt; &quot; &quot;;    &#125;&#125;void dfs(string&amp; s, int n, int idx)&#123;    // end case for idx == n    if(idx == n)&#123;        printNum(s);        break;    &#125;    // fill s from 00..0 ~ 00...9    for(int i = 0; i &lt; 10; i++)&#123;        s[idx] = &#39;0&#39; + i;        dfs(s, n, idx + 1);    &#125;&#125;void printNum(int n)&#123;    // init  s to save n bit nums    string s(n, &#39;0&#39;);    // dfs to print string nums    dfs(s, n, 0);&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;剑指OFFER&quot;&gt;&lt;a href=&quot;#剑指OFFER&quot; class=&quot;headerlink&quot; title=&quot;剑指OFFER&quot;&gt;&lt;/a&gt;剑指OFFER&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：输入正整数n,</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指OFFER系列之18----删除重复节点</title>
    <link href="http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B18----%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B18----%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</id>
    <published>2022-01-19T14:59:34.339Z</published>
    <updated>2022-01-19T15:01:37.874Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="剑指OFFER"><a href="#剑指OFFER" class="headerlink" title="剑指OFFER"></a>剑指OFFER</h3><blockquote><p>题目描述：在一个排序的链表中删除重复节点。比如，删除链表 1 -&gt; 2 -&gt; 3 -&gt;3 -&gt; 4 -&gt; 4 -&gt; 5 的重复节点的结果为：1 -&gt; 2 -&gt; 5</p></blockquote><pre><code>ListNode* deleteDuplicate(ListNode* head)&#123;    ListNode* dummy = new ListNode(-1);    ListNode* ans = dummy;    dummy -&gt; next = head;    ListNode* cur = head -&gt; next;    while(cur)&#123;        if(dummy -&gt; next -&gt; val == cur -&gt; val)&#123;            while(dummy -&gt; next -&gt; val == cur -&gt; val)&#123;                cur = cur -&gt; next;                if(!cur)&#123;                    dummy -&gt; next = cur;                    return ans -&gt; next;                &#125;            &#125;            dummy -&gt; next = cur;            cur = cur -&gt; next;        &#125;else&#123;            dummy = dummy -&gt; next;            cur = cur -&gt; next;        &#125;    &#125;    return ans -&gt; next;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;剑指OFFER&quot;&gt;&lt;a href=&quot;#剑指OFFER&quot; class=&quot;headerlink&quot; title=&quot;剑指OFFER&quot;&gt;&lt;/a&gt;剑指OFFER&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：在一个排序的链</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指OFFER系列之12----矩阵中的路径</title>
    <link href="http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B12----%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B12----%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2022-01-19T14:59:34.291Z</published>
    <updated>2022-01-19T15:01:37.862Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="剑指OFFER"><a href="#剑指OFFER" class="headerlink" title="剑指OFFER"></a>剑指OFFER</h3><blockquote><p>题目描述：设计一个函数判断一个矩阵是否存在一条包含某字符串的所有字符的路径。</p></blockquote><pre><code>bool hasPath(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, int i, int j, string s, int idx, vector&lt;vector&lt;int&gt;&gt;&amp; visited)&#123;        if(idx == s.size())&#123;            return true;        &#125;        int rows = matrix.size();        int cols = matrix[0].size();        if(i &gt;= rows || i &lt; 0 || j &gt;= cols || j &lt; 0)&#123;            return false;        &#125;        if(visited[i][j] == 1 || matrix[i][j] != s[idx])&#123;            return false;        &#125;        visited[i][j] = 1;        bool flag = hasPath(matrix, i+1, j, s, idx+1, visited);        flag = flag || hasPath(matrix, i, j+1, s, idx+1, visited);        flag = flag || hasPath(matrix, i-1, j, s, idx+1, visited);        flag = flag || hasPath(matrix, i, j-1, s, idx+1, visited);        if(flag)&#123;            return true;        &#125;        visited[i][j] = 0;        return false;    &#125;    bool matrixPath(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string s)&#123;        int rows = matrix.size();        int cols = matrix[0].size();        vector&lt;vector&lt;int&gt;&gt; visited(rows, vector&lt;int&gt;(cols, 0));        for(int i = 0; i &lt; rows; i++)&#123;            for(int j = 0; j &lt; cols; j++)&#123;                if(hasPath(matrix, i, j, s, 0, visited))&#123;                    return true;                &#125;            &#125;        &#125;        return false;    &#125;;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;剑指OFFER&quot;&gt;&lt;a href=&quot;#剑指OFFER&quot; class=&quot;headerlink&quot; title=&quot;剑指OFFER&quot;&gt;&lt;/a&gt;剑指OFFER&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：设计一个函数判</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指OFFER系列之25----合并两个排序链表（拓展：合并K个链表）</title>
    <link href="http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B25----%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E6%8B%93%E5%B1%95%EF%BC%9A%E5%90%88%E5%B9%B6K%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%89/"/>
    <id>http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B25----%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E6%8B%93%E5%B1%95%EF%BC%9A%E5%90%88%E5%B9%B6K%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%89/</id>
    <published>2022-01-19T14:59:34.223Z</published>
    <updated>2022-01-19T15:01:37.862Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="剑指OFFER"><a href="#剑指OFFER" class="headerlink" title="剑指OFFER"></a>剑指OFFER</h3><blockquote><p>题目描述：输入两个有序链表，合并两个链表使新的链表仍然是增序链表。</p></blockquote><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;climits&gt;/* *merge to sorted list * */using namespace std;struct ListNode&#123;    int val;    ListNode* next;    ListNode():val(0), next(nullptr)&#123;&#125;    ListNode(int x):val(x), next(nullptr)&#123;&#125;&#125;;ListNode* readData()&#123;    cout &lt;&lt; &quot;enter list: &quot;;    int val;    cin &gt;&gt; val;    ListNode* head = new ListNode(val);    ListNode* cur = head;    while(cin.get() != &#39;\n&#39;)&#123;        cin &gt;&gt; val;        ListNode* temp = new ListNode(val);        cur -&gt; next = temp;        cur = temp;    &#125;    return head;&#125;void showList(string s, ListNode* head)&#123;    cout &lt;&lt; s &lt;&lt; endl;    ListNode* cur = head;    while(cur)&#123;        cout &lt;&lt; cur -&gt; val &lt;&lt; &quot; -&gt; &quot;;        cur = cur -&gt; next;    &#125;    cout &lt;&lt; &quot;null&quot; &lt;&lt; endl;&#125;ListNode* mergeTwo(ListNode* l1, ListNode* l2)&#123;    if(!l1)&#123;        return l2;    &#125;    if(!l2)&#123;        return l1;    &#125;    if(l1 -&gt; val &lt; l2 -&gt; val)&#123;        l1 -&gt; next = mergeTwo(l1 -&gt; next, l2);        return l1;    &#125;    l2 -&gt; next = mergeTwo(l1, l2 -&gt; next);    return l2;&#125;// add merge K list method based on mergeTwo with divide-and-conquer algorithmListNode* mergeKList(vector&lt;ListNode*&gt;&amp; lists)&#123;    if(lists.size() == 0)&#123;        return nullptr;    &#125;    if(lists.size() == 1)&#123;        return lists[0];    &#125;    vector&lt;ListNode*&gt; list2;    for(int i = 0; i &lt; lists.size() / 2; i++)&#123;        list2.push_back(lists.back());        lists.pop_back();    &#125;    return mergeTwo(mergeKList(lists), mergeKList(list2));&#125;void utils()&#123;    cout &lt;&lt; &quot;enter num of lists : &quot;;    int n;    cin &gt;&gt; n;    vector&lt;ListNode*&gt; lists;    for(int i = 0; i &lt; n; i++)&#123;        ListNode* node = readData();        lists.push_back(node);    &#125;    ListNode* ans = mergeKList(lists);    showList(&quot;ans : &quot;, ans);&#125;int main()&#123;    utils();    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;剑指OFFER&quot;&gt;&lt;a href=&quot;#剑指OFFER&quot; class=&quot;headerlink&quot; title=&quot;剑指OFFER&quot;&gt;&lt;/a&gt;剑指OFFER&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：输入两个有序链</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指OFFER系列之36----二叉搜索树与双向链表</title>
    <link href="http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B36----%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B36----%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-19T14:59:34.155Z</published>
    <updated>2022-01-19T15:01:37.650Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="剑指OFFER"><a href="#剑指OFFER" class="headerlink" title="剑指OFFER"></a>剑指OFFER</h3><blockquote><p>题目描述：输入一颗二叉搜索树，将该二叉搜索树转换为一个排序的双向链表。</p></blockquote><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;climits&gt;using namespace std;struct TreeNode&#123;    int val;    TreeNode* left;    TreeNode* right;    TreeNode(): val(-1), left(nullptr), right(nullptr)&#123;&#125;    TreeNode(int x): val(x), left(nullptr), right(nullptr)&#123;&#125;&#125;;void convertNode(TreeNode* root, TreeNode** biList)&#123;    if(!root)&#123;        return;    &#125;    TreeNode* cur = root;    if(cur -&gt; left)&#123;        convertNode(cur -&gt; left, biList);    &#125;    cur -&gt; left = *biList;    if(*biList)&#123;        (*biList) -&gt; right = cur;    &#125;    *biList = cur;    if(cur -&gt; right)&#123;        convertNode(cur -&gt; right, biList);    &#125;&#125;TreeNode* convert(TreeNode* root)&#123;    TreeNode* biList = nullptr;    convertNode(root, &amp;biList);    TreeNode* biHead = biList;    while(biHead &amp;&amp; biHead -&gt; left)&#123;        biHead = biHead -&gt; left;    &#125;    return biHead;&#125;void buildTree(TreeNode* n1, TreeNode* n2, TreeNode* n3)&#123;    if(n1)&#123;        n1 -&gt; left = n2;        n1 -&gt; right = n3;    &#125;&#125;void showNode(TreeNode* node)&#123;    if(!node)&#123;        cout &lt;&lt;&quot; -&gt; null &quot;;    &#125;else&#123;        if(node -&gt; left)&#123;            cout &lt;&lt; node -&gt; left -&gt; val;        &#125;else&#123;            cout &lt;&lt; &quot;null &quot;;        &#125;        cout &lt;&lt; &quot; &lt;- &quot; &lt;&lt; node -&gt; val &lt;&lt;  &quot; -&gt; &quot;;        if(node -&gt; right)&#123;            cout &lt;&lt;  node -&gt; right -&gt; val;        &#125;else&#123;            cout &lt;&lt; &quot;null&quot;;        &#125;    &#125;    cout &lt;&lt; endl;&#125;void showTree(TreeNode* root)&#123;    showNode(root);    if(root)&#123;        if(root -&gt; left)&#123;            showNode(root -&gt; left);        &#125;            if(root -&gt; right)&#123;            showNode(root -&gt; right);        &#125;    &#125;&#125;void showList(TreeNode* biHead)&#123;    TreeNode* cur = biHead;    cout &lt;&lt; &quot;from left to right: &quot;;    while(cur)&#123;        cout &lt;&lt; cur -&gt; val &lt;&lt; &quot; -&gt; &quot;;        if(!cur -&gt; right)&#123;            break;        &#125;        cur = cur -&gt; right;    &#125;    cout &lt;&lt; &quot;null&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;from right to left: &quot;;    while(cur)&#123;        cout &lt;&lt; cur -&gt; val &lt;&lt; &quot; -&gt; &quot;;        if(!cur -&gt; left)&#123;            break;        &#125;        cur = cur -&gt; left;    &#125;    cout&lt;&lt; &quot;null&quot; &lt;&lt; endl;&#125;void utils()&#123;    TreeNode* node1 = new TreeNode(10);    TreeNode* node2 = new TreeNode(6);    TreeNode* node3 = new TreeNode(14);    TreeNode* node4 = new TreeNode(4);    TreeNode* node5 = new TreeNode(8);    TreeNode* node6 = new TreeNode(12);    TreeNode* node7 = new TreeNode(16);    buildTree(node1, node2, node3);    buildTree(node2, node4, node5);    buildTree(node3, node6, node7);        cout &lt;&lt; &quot;input : &quot; &lt;&lt; endl;    showTree(node1);    cout &lt;&lt; &quot;output : &quot; &lt;&lt; endl;    TreeNode* ans = convert(node1);    showList(ans);&#125;int main()&#123;    utils();    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;剑指OFFER&quot;&gt;&lt;a href=&quot;#剑指OFFER&quot; class=&quot;headerlink&quot; title=&quot;剑指OFFER&quot;&gt;&lt;/a&gt;剑指OFFER&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：输入一颗二叉搜</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指OFFER系列之31----栈的压入和弹出序列</title>
    <link href="http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B31----%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B31----%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</id>
    <published>2022-01-19T14:59:34.059Z</published>
    <updated>2022-01-19T15:01:37.442Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="剑指OFFER"><a href="#剑指OFFER" class="headerlink" title="剑指OFFER"></a>剑指OFFER</h3><blockquote><p>题目描述：输入两个整数序列，第一个序列表示栈的压入序列，判断第二个序列是否为栈的出栈序列。</p></blockquote><pre><code>bool isPopOrder(vector&lt;int&gt;&amp; in, vector&lt;int&gt;&amp; out)&#123;    stack&lt;int&gt; s;    int n = in.size(), idx = 0;    for(int i = 0; i &lt; n; i++)&#123;        s.push(in[i]);        while(!s.empty() &amp;&amp; s.top() == out[idx])&#123;            s.pop();            idx++;        &#125;    &#125;    return idx == n ? true : false;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;剑指OFFER&quot;&gt;&lt;a href=&quot;#剑指OFFER&quot; class=&quot;headerlink&quot; title=&quot;剑指OFFER&quot;&gt;&lt;/a&gt;剑指OFFER&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：输入两个整数序</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指OFFER系列之40----最小的K个数</title>
    <link href="http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B40----%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/"/>
    <id>http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B40----%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</id>
    <published>2022-01-19T14:59:34.027Z</published>
    <updated>2022-01-19T15:01:37.502Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="剑指OFFER"><a href="#剑指OFFER" class="headerlink" title="剑指OFFER"></a>剑指OFFER</h3><blockquote><p>题目描述：输入n个整数，找出最小的k个数。</p></blockquote><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;climits&gt;#include&lt;queue&gt;using namespace std;// method 1 : priority_queuevector&lt;int&gt; getLeastNums(vector&lt;int&gt;&amp; nums, int k)&#123;    if(k == 0 || nums.size() &lt;= k)&#123;        return nums;    &#125;    vector&lt;int&gt; ans;    priority_queue&lt;int&gt; q;    for(int i = 0; i &lt; k; i++)&#123;        q.push(nums[i]);    &#125;    for(int i = k; i &lt; nums.size(); i++)&#123;        if(q.top() &gt; nums[i])&#123;            q.pop();            q.push(nums[i]);        &#125;    &#125;    for(int i = 0; i &lt; k; i++)&#123;        ans.push_back(q.top());        q.pop();    &#125;    return ans;&#125;int partion(vector&lt;int&gt;&amp;nums, int left, int right)&#123;    int idx = left;    int key = nums[left];    for(int i = left + 1; i &lt;= right; i++)&#123;        if(nums[i] &lt; key)&#123;            idx++;            swap(nums[i], nums[idx]);        &#125;    &#125;    swap(nums[left], nums[idx]);    return idx;&#125;void quickSort(vector&lt;int&gt;&amp; nums, int left, int right, int k)&#123;    int idx = partion(nums, left, right);    if(idx == k)&#123;        return;    &#125;else if(idx &lt; k)&#123;        quickSort(nums, idx + 1, right, k);    &#125;else&#123;        quickSort(nums, left, idx - 1, k);    &#125;&#125;// method 2 : quickSortvector&lt;int&gt; getLeastNumsII(vector&lt;int&gt;&amp; nums, int k)&#123;    if(k == 0 || nums.size() &lt;= k)&#123;        return nums;    &#125;    vector&lt;int&gt; ans;    quickSort(nums, 0, nums.size() - 1, k);    for(int i = 0; i &lt; k; i++)&#123;        ans.push_back(nums[i]);    &#125;    return ans;&#125;void showVector(string s, vector&lt;int&gt;&amp; nums)&#123;    cout &lt;&lt; s &lt;&lt; endl;    for(auto i : nums)&#123;        cout &lt;&lt; i &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void utils()&#123;    vector&lt;int&gt; nums;    int val, k;    cout &lt;&lt; &quot;enter nums: &quot;;    cin &gt;&gt; val;    nums.push_back(val);    while(cin.get() != &#39;\n&#39;)&#123;        cin &gt;&gt; val;        nums.push_back(val);    &#125;    showVector(&quot;input: &quot;, nums);    cout &lt;&lt; &quot;enter k: &quot;;    cin &gt;&gt; k;    vector&lt;int&gt; ans = getLeastNums(nums, k);    showVector(&quot;output: &quot;, ans);    ans = getLeastNumsII(nums, k);    showVector(&quot;outputII: &quot;, ans);&#125;int main()&#123;    utils();    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;剑指OFFER&quot;&gt;&lt;a href=&quot;#剑指OFFER&quot; class=&quot;headerlink&quot; title=&quot;剑指OFFER&quot;&gt;&lt;/a&gt;剑指OFFER&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：输入n个整数，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指OFFER系列之34----二叉树中和为某一值的路径</title>
    <link href="http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B34----%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B34----%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2022-01-19T14:59:33.959Z</published>
    <updated>2022-01-19T15:01:37.502Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="剑指OFFER"><a href="#剑指OFFER" class="headerlink" title="剑指OFFER"></a>剑指OFFER</h3><blockquote><p>热身：输入一颗二叉树和一个整数，判断是否存在从根节点到叶节点和为给定整数的路径。</p></blockquote><pre><code>class Solution&#123;    bool ans;public:    void pathSum(TreeNode* root, int sum, int curSum)&#123;        if(!root)&#123;            return;        &#125;        curSum += root -&gt; val;        if(!root -&gt; left &amp;&amp; !root -&gt; right &amp;&amp; curSum == sum)&#123;            ans = true;        &#125;        pathSum(root -&gt; left, sum, curSum);        pathSum(root -&gt; right, sum, curSum);    &#125;    bool pathSum(TreeNode* root, int sum)&#123;        pathSum(root, sum, 0);        return ans;    &#125;&#125;;</code></pre><blockquote><p>题目描述：输入一颗二叉树和一个整数，输出所有树节点和等于给定整数的路径。</p></blockquote><pre><code>class Solution&#123;    vector&lt;vector&lt;int&gt;&gt; ans;public:    void pathSum(TreeNode* root, int sum, int curSum, vector&lt;int&gt; temp)&#123;        if(!root)&#123;            return;        &#125;        curSum += root -&gt; val;        temp.push_back(root -&gt; val);        if(!root -&gt; left &amp;&amp; !root -&gt; right &amp;&amp; curSum == sum)&#123;            ans.push_back(temp);        &#125;        pathSum(root -&gt; left, sum, curSum, temp);        pathSum(root -&gt; right, sum, curSum, temp);        temp.pop_back();    &#125;    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum)&#123;        vector&lt;int&gt; temp;        pathSum(TreeNode* root, sum, 0, temp);        return ans;    &#125;&#125;;</code></pre><blockquote><p>变式：输入一颗二叉树和一个整数，输出树中联系节点和等于给定整数的个数。</p></blockquote><pre><code>class Solution&#123;public:    int pathSumWithRoot(TreeNode* root, int sum)&#123;        if(!root)&#123;            return 0;        &#125;        int count = root -&gt; val == sum ? 1 : 0;        count += pathSumWithRoot(root -&gt; left, sum - root -&gt; val);        count += pathSumWithRoot(root -&gt; right, sum - root -&gt; val);        return count;    &#125;    int pathSum(TreeNode* root, int sum)&#123;        return root ? pathSumWithRoot(root, sum) + pathSum(root -&gt; left, sum -- root -&gt; val) + pathSum(root -&gt; right, sum - root -&gt; val) : 0;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;剑指OFFER&quot;&gt;&lt;a href=&quot;#剑指OFFER&quot; class=&quot;headerlink&quot; title=&quot;剑指OFFER&quot;&gt;&lt;/a&gt;剑指OFFER&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;热身：输入一颗二叉树和一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指OFFER系列之46----把数字翻译成字符串</title>
    <link href="http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B46----%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B46----%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-01-19T14:59:33.911Z</published>
    <updated>2022-01-19T15:01:37.502Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="剑指OFFER"><a href="#剑指OFFER" class="headerlink" title="剑指OFFER"></a>剑指OFFER</h3><blockquote><p>题目描述：输入一个数字，按照如下规则把它翻译成字符串：0翻译成”a”，1翻译成”b”，…, 25翻译成”z”。一个数字可能有多个翻译。例如12258有5中不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”。请编程实现一个函数，用来计算一个数字可以有多少种翻译方式。</p></blockquote><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;climits&gt;using namespace std;bool checkNum(string&amp; s, int idx)&#123;    if(idx &lt; 0 || idx &gt;= s.size())&#123;        return false;    &#125;    if(s[idx - 1] - &#39;0&#39; == 0)&#123;        return false;    &#125;    int temp = 10 * (s[idx - 1] - &#39;0&#39;) + (s[idx] - &#39;0&#39;);    if(temp &gt;= 0 &amp;&amp; temp &lt; 26)&#123;        return true;    &#125;    return false;&#125;int transNum(int val)&#123;    string s = to_string(val);    int n = s.size();    vector&lt;int&gt; dp(n, 1);    if(checkNum(s, 1))&#123;        dp[1] = 2;    &#125;    for(int i = 2; i &lt; n; i++)&#123;        if(checkNum(s, i))&#123;            dp[i] = dp[i-1] + dp[i-2];        &#125;else&#123;            dp[i] = dp[i-1];        &#125;    &#125;    return dp[n-1];&#125;void utils()&#123;    cout &lt;&lt; &quot;enter num: &quot;;    int val;    cin &gt;&gt; val;    cout &lt;&lt; &quot;total: &quot; &lt;&lt; transNum(val) &lt;&lt; endl;&#125;int main()&#123;    utils();    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;剑指OFFER&quot;&gt;&lt;a href=&quot;#剑指OFFER&quot; class=&quot;headerlink&quot; title=&quot;剑指OFFER&quot;&gt;&lt;/a&gt;剑指OFFER&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：输入一个数字，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OpenCV----简单对象分类</title>
    <link href="http://example.com/2022/01/19/OpenCV----%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB/"/>
    <id>http://example.com/2022/01/19/OpenCV----%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB/</id>
    <published>2022-01-19T14:59:33.851Z</published>
    <updated>2022-01-19T15:01:37.146Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>题目要求：在上一章<a href="https://blog.csdn.net/qq_37172182/article/details/122088583">OpenCV—-简单目标提取和分割</a>中尝试使用opencv连通性方法获取了目标的面积和轮廓信息，本章节将尝试对这些特征进行整合，使用opencv中ml库(machine learning)训练一个目标分类器,给定一种输入图片，预测图像中目标的类别。<br>最新代码库已更新：<a href="https://github.com/GinkgoX/opencv4_cpp">opencv4_cpp  </a></p><blockquote><p>分析：<br>1）了解常用的分类模型，参见opencv ml API <a href="https://docs.opencv.org/4.5.0/d8/df1/namespacecv_1_1ml.html">OpenCV namespace ml</a>,首先建议一个简单的SVM分类器，然后设计其他的分类器如朴素贝叶斯模型等；<br>2）设计命令行设置输入图片和模型选择等，支持默认模型选择；<br>3）考虑模板类进行分类模型选择的通用能力；<br>4）支持模型参数手动设定；<br>5）进代码设计成便于管理，解释性强的工程，设计通用的工程模板；</p></blockquote><ul><li><p>文件工程目录<br>  ·bin ——————生成可执行文件目录<br>  ·build —————-文件编译的中间结果<br>  ·data —————–训练测试数据（图像）<br>  ·include ————-头文件目录和inline文件（用于模板方法实现）<br>  ·lib ——————–用于生成头文件的lib文件<br>  ·model ————–不同模型训练生成的xml文件<br>  ·src ——————-源文件和源文件编译命令CMakeLists.txt<br>  ·CMakeLists.txt —外层文件编译命令<br>  <img src="https://img-blog.csdnimg.cn/b4f6dc93d4c041b1a08fd06738a642ac.png" alt="请添加图片描述"></p></li><li><p>outer CMakeLists.txt</p><p>  cmake_minimum_required (VERSION 3.0)</p><p>  PROJECT(ch6)</p><p>  set(CMAKE_BUILD_TYPE Release)<br>  set(CMAKE_CXX_FLAGS “-std=c++17 -Wall”)<br>  set(CMAKE_CXX_FLAGS_RELEASE  “-std=c++17 -O3 -fopenmp -pthread”)</p><p>  IF(EXISTS ${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)</p><pre><code>  include($&#123;CMAKE_BINARY_DIR&#125;/conanbuildinfo.cmake)  conan_basic_setup()</code></pre><p>  ENDIF()</p><p>  set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)<br>  set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)<br>  include_directories(${PROJECT_SOURCE_DIR}/include)<br>  link_directories(${PROJECT_SOURCE_DIR}/lib)<br>  add_subdirectory(${PROJECT_SOURCE_DIR}/src)</p></li><li><p>inner CMakeLists.txt</p><p>  cmake_minimum_required (VERSION 3.0)</p><p>  set(CMAKE_BUILD_TYPE Release)<br>  set(CMAKE_CXX_FLAGS “-std=c++17 -Wall”)<br>  set(CMAKE_CXX_FLAGS_RELEASE  “-std=c++17 -O3 -fopenmp -pthread”)</p><p>  include_directories(${PROJECT_SOURSE_DIR}/include)</p><h1 id="Requires-OpenCV"><a href="#Requires-OpenCV" class="headerlink" title="Requires OpenCV"></a>Requires OpenCV</h1><p>  find_package(OpenCV  REQUIRED)</p><p>  message(“OpenCV version : ${OpenCV_VERSION}”)</p><p>  include_directories(${OpenCV_INCLUDE_DIRS})<br>  link_directories(${OpenCV_LIB_DIR})</p><p>  add_library(utils utils.cpp)<br>  add_library(mwindow mwindow.cpp)<br>  add_executable(main main.cpp)<br>  target_link_libraries(main ${OpenCV_LIBS} utils mwindow -lopencv_ml)</p></li><li><p>结果演示</p><p>   ./bin/main data/test.pgm  data/pattern.pgm bayes</p></li></ul><p><img src="https://img-blog.csdnimg.cn/bbf71bc21d6841bbb6d7d6dfa701a183.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfMzcxNzIxODI=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><pre><code>./bin/main data/test.pgm  data/pattern.pgm (svm)</code></pre><p><img src="https://img-blog.csdnimg.cn/0ed56279d9d545c1903c36d9ca3cbdf3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfMzcxNzIxODI=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><pre><code>./bin/main data/test.pgm  data/pattern.pgm boost</code></pre><p><img src="https://img-blog.csdnimg.cn/0c4f3735cc4c4f6fae5310a8e28d2a5e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfMzcxNzIxODI=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><ul><li><p>代码示例<br>  1）更新之前的多窗口类MWindow Class</p><p>  /*<br>  @File          :mwindow.hpp<br>  @Description:  :<br>  @Date          :2021/12/25 09:23:14<br>  @Author        :xieyin<br>  @version       :1.0<br>  */<br>  #pragma once</p><p>  #include<iostream><br>  #include<string><br>  #include<vector><br>  using namespace std;</vector></string></iostream></p><p>  #include&lt;opencv2/core.hpp&gt;<br>  #include&lt;opencv2/highgui.hpp&gt;<br>  using namespace cv;</p><p>  class MWindow{</p><pre><code>  public:      // consturtor      MWindow(string windowTitle, int rows, int cols, int height=700, int width=1200, int flags=WINDOW_AUTOSIZE);      // add image into canvas      int addImage(string title, Mat img, bool render = false);      // remove image from canvas      void removeImage(int pos);      // adjust all image size in canvas      void render();  private:      string mWindowTitle;      int mRows;      int mCols;      Mat mCanvas;      vector&lt;string&gt; mSubTitles;      vector&lt;Mat&gt; mSubImages;     </code></pre><p>  };</p><p>  /*<br>  @File          :mwindow.cpp<br>  @Description:  :<br>  @Date          :2021/12/25 09:23:22<br>  @Author        :xieyin<br>  @version       :1.0<br>  */</p><p>  #include<iostream><br>  #include<string><br>  #include<vector><br>  using namespace std;</vector></string></iostream></p><p>  #include&lt;opencv2/core.hpp&gt;<br>  #include&lt;opencv2/highgui.hpp&gt;<br>  #include&lt;opencv2/opencv.hpp&gt;<br>  #include&lt;opencv2/imgproc.hpp&gt;<br>  using namespace cv;</p><p>  #include”mwindow.hpp”</p><p>  MWindow::MWindow(string windowTitle, int rows, int cols, int height, int width, int flags):mWindowTitle(windowTitle), mRows(rows), mCols(cols){</p><pre><code>  /*  @description  : MWindow constructor  @param  :       windowTitle : whole window title      rows : sub window rows      cols : sub window cols      flags : namedWindow flags (eg, WINDOW_AUTOSIZE)  @Returns  :   */ // create canvas  namedWindow(mWindowTitle, flags);  mCanvas = Mat(height, width, CV_8UC3);  imshow(mWindowTitle, mCanvas);</code></pre><p>  }</p><p>  int MWindow::addImage(string title, Mat img, bool render){</p><pre><code>  /*  @description  : add title and image into canvas  @param  :       title : sub image title      img : image to be added      render : render(flag) whether need to adjust the image for canvas  @Returns  :       index : sub image index in total mRows * mCols  */ int index=-1;  for(int i=0; i&lt;mSubTitles.size(); i++)&#123;      string t=this-&gt;mSubTitles[i];      if(t.compare(title)==0)&#123;          index=i;          break;      &#125;  &#125;  if(index==-1)&#123;      mSubTitles.push_back(title);      mSubImages.push_back(img);  &#125;else&#123;      mSubImages[index]= img;  &#125;  if(render)&#123;      MWindow::render();  &#125;  return mSubImages.size() - 1;</code></pre><p>  }</p><p>  void MWindow::removeImage(int pos){</p><pre><code>  /*  @description  : remove image from canvas based on index  @param  :       pos : sub image index in total mRows * mCols  @Returns  :       None  */  mSubTitles.erase(mSubTitles.begin() + pos);  mSubImages.erase(mSubImages.begin() + pos);</code></pre><p>  }</p><p>  void MWindow::render(){</p><pre><code>  /*  @description  : fill title and image into canvas in suitable way  @param  :       None  @Returns  :      None   */  mCanvas.setTo(Scalar(20, 20, 20));  // get sub canvas size  int cellH = mCanvas.rows / mRows;  int cellW = mCanvas.cols / mCols;  // set total number of images to load  int n = mSubImages.size();  int numImgs = n &gt; mRows * mCols ? mRows * mCols : n;  for(int i = 0; i &lt; numImgs; i++)&#123;      // get title      string title = mSubTitles[i];      // get sub canvas top left location      int cellX = (cellW) * ((i) % mCols);      int cellY = (cellH) * floor( (i) / (float) mCols);      Rect mask(cellX, cellY, cellW, cellH);      // set subcanvas size      rectangle(mCanvas, Rect(cellX, cellY, cellW, cellH), Scalar(200, 200, 200), 1);      Mat cell(mCanvas, mask);      Mat imgResz;      // get cell aspect      double cellAspect = (double) cellW / (double) cellH;      // get image      Mat img = mSubImages[i];      // get image aspect      double imgAspect = (double) img.cols / (double) img.cols;      double wAspect = (double) cellW / (double) img.cols;      double hAspect = (double) cellH / (double) img.rows;      // get suitable aspect and resize image      double aspect = cellAspect &lt; imgAspect ? wAspect : hAspect;      resize(img, imgResz, Size(0, 0), aspect, aspect);      // if gray image, convert to BGR      if(imgResz.channels() == 1)&#123;          cvtColor(imgResz, imgResz, COLOR_GRAY2BGR);      &#125;      Mat subCell(mCanvas, Rect(cellX, cellY, imgResz.cols, imgResz.rows));      imgResz.copyTo(subCell);      putText(cell, title, Point(20, 20), FONT_HERSHEY_SIMPLEX, 0.6, Scalar(255, 0, 0));  &#125;  // show total canvas  imshow(mWindowTitle, mCanvas);</code></pre><p>  }</p><p>  2）设计通用辅助函数utils.hpp, utills.cpp和utils.inl</p><p>  /*<br>  @File          :utils.hpp<br>  @Description:  :<br>  @Date          :2021/12/25 09:23:48<br>  @Author        :xieyin<br>  @version       :1.0<br>  */<br>  #pragma once<br>  #include<string><br>  #include<cmath><br>  #include<memory><br>  using namespace std;</memory></cmath></string></p><p>  #include &lt;opencv2/core.hpp&gt;<br>  #include &lt;opencv2/imgproc.hpp&gt;<br>  #include &lt;opencv2/highgui.hpp&gt;<br>  #include &lt;opencv2/ml.hpp&gt;<br>  using namespace cv;<br>  using namespace cv::ml;</p><p>  #include”mwindow.hpp”</p><p>  extern shared_ptr<MWindow> myWin;</MWindow></p><p>  // generate randow color basd on randow number generator<br>  Scalar randColor(RNG&amp; rng);</p><p>  // calculate given img’s light pattert with large kernel’s Blur operation<br>  Mat calLigthPattern(Mat img);</p><p>  // use 2 tpyes of light removal method, 0 diff, 1 div, defalut is 0<br>  Mat removeLight(Mat img, Mat pattern, int methodLight=0);</p><p>  // packed opencv lib connectedComponents function<br>  Mat connectedComponents(Mat img_thr);</p><p>  // packed opencv lib connectedComponentsWithStats function<br>  Mat connectedComponentsWithStats(Mat img_thr);</p><p>  // packed opencv lib findContours function<br>  Mat findContours(Mat img_thr);</p><p>  // helper function for trainAndTest, readFolderAndExtractFeatures<br>  bool readFolderAndExtractFeatures(string filePath, int label, int numTest, </p><pre><code>  vector&lt;float&gt;&amp; trainingData, vector&lt;int&gt;&amp; trainResponses, vector&lt;float&gt;&amp; testData, vector&lt;int&gt;&amp; testResponses);</code></pre><p>  // helper function for trainAndTest, ploat data error<br>  void plotData(Mat trainingDataMat, Mat trainResponsesMat, string mode=”svm”, float* error=NULL);</p><p>  // define svm parameters<br>  void defineSVM(Ptr<SVM>&amp; svm);</SVM></p><p>  // the train and test process for mechain learning<br>  template<typename t><br>  void trainAndTest(string mode=”svm”);</typename></p><p>  // train svm model<br>  void trainSVM();</p><p>  // predict features extracted from imgOut, and put text in left top position<br>  template<typename t><br>  void predict(vector&lt;vector<float>&gt; features, vector<int> posLeft, vector<int> posTop, string mode, Mat&amp; imgOut);</int></int></float></typename></p><p>  // preprocess test image<br>  Mat preProcess(Mat img);</p><p>  // extract feature from preprocess image and get left top location<br>  vector&lt;vector<float>&gt; extractFeatures(Mat img, vector<int>* posLeft=NULL, vector<int>* posTop=NULL);</int></int></float></p><p>  #include”utils.inl”</p><p>  /*<br>  @File          :utils.cpp<br>  @Description:  :<br>  @Date          :2021/12/25 09:23:38<br>  @Author        :xieyin<br>  @version       :1.0<br>  */<br>  #include<string><br>  #include<cmath><br>  #include<memory><br>  #include<iostream><br>  #include<vector><br>  using namespace std;</vector></iostream></memory></cmath></string></p><p>  #include&lt;opencv2/core.hpp&gt;<br>  #include&lt;opencv2/highgui.hpp&gt;<br>  #include&lt;opencv2/imgproc.hpp&gt;<br>  #include&lt;opencv2/opencv.hpp&gt;<br>  #include&lt;opencv2/ml.hpp&gt;<br>  using namespace cv;<br>  using namespace cv::ml;</p><p>  #include”utils.hpp”<br>  #include”mwindow.hpp”</p><p>  Scalar randColor(RNG&amp; rng){</p><pre><code>  /*  @description  : generate randow color  @param  :       rng : random number generator object  @Returns  :       Sacalar() : BGR scalar  */  auto iColor = (unsigned)rng;  return Scalar(iColor&amp;255, (iColor &gt;&gt; 8)&amp;255, (iColor &gt;&gt; 16)&amp;255);</code></pre><p>  }</p><p>  Mat calLigthPattern(Mat img){</p><pre><code>  /*  @description  : get source image&#39;s light pattern   @param  :       img : source BGR image or Gray image  @Returns  :       pattern : the light pattern  */  Mat pattern;  blur(img, pattern, Size(img.cols / 3, img.cols / 3));  return pattern;</code></pre><p>  }</p><p>  Mat removeLight(Mat img, Mat pattern, int methodLight){</p><pre><code>  /*  @description  : remove light between img and pattern based on method light  @param  :       img : source BGR/Gray image      pattern : pattern BGR/Gray image      methodLight : choise options: 0 difference, 1 div  @Returns  :       aux : light removed BGR/Gray image  */  Mat aux;  if(methodLight == 1)&#123;      // div operation in float 32 format CV_32F      Mat img32, pattern32;      img.convertTo(img32, 5);      pattern.convertTo(pattern32, 5);      aux = 1.0 - (img32 / pattern32);      // covert to CV_8U and clip      aux.convertTo(aux, 0, 255);  &#125;  else&#123;      // difference      aux = pattern - img;  &#125;  return aux;</code></pre><p>  }</p><p>  Mat connectedComponents(Mat img_thr){</p><pre><code>  /*  @description  : opencv connnected components  @param  :       img : threshold image  @Returns  :       None  */ Mat labels; auto num_objs = connectedComponents(img_thr, labels); Mat res; if(num_objs &lt; 2)&#123;     cout &lt;&lt; &quot;no object is detected. &quot; &lt;&lt; endl;     return res; &#125; res = Mat::zeros(img_thr.rows, img_thr.cols, CV_8UC3); RNG rng(0xFFFFFFFF); for(auto i = 1; i &lt; num_objs; i++)&#123;     Mat mask = labels == i;     res.setTo(randColor(rng), mask); &#125; return res;</code></pre><p>  }</p><p>  Mat connectedComponentsWithStats(Mat img_thr){</p><pre><code>  /*  @description  : connnected components with stats  @param  :       img : threshold image  @Returns  :       None  */  Mat labels, stats, centroids;  auto num_objs = connectedComponentsWithStats(img_thr, labels, stats, centroids);  Mat res;  if(num_objs &lt; 2)&#123;     cout &lt;&lt; &quot;no object is detected. &quot; &lt;&lt; endl;     return res; &#125; res = Mat::zeros(img_thr.rows, img_thr.cols, CV_8UC3); RNG rng(0xFFFFFFFF); for(auto i = 1; i &lt; num_objs; i++)&#123;     Mat mask = labels == i;     res.setTo(randColor(rng), mask);     stringstream ss;     ss &lt;&lt; &quot;area: &quot; &lt;&lt; stats.at&lt;int&gt;(i, CC_STAT_AREA);     // add text info     putText(res, ss.str(), centroids.at&lt;Point2d&gt;(i), FONT_HERSHEY_SIMPLEX, 0.3, Scalar(0, 255, 0)); &#125; return res;</code></pre><p>  }</p><p>  Mat findContours(Mat img_thr){</p><pre><code>  /*  @description  : find contours and put text  @param  :       img : threshold image  @Returns  :       None  */  vector&lt;vector&lt;Point&gt;&gt; contours;  findContours(img_thr, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);  Mat res;  if(contours.size() == 0)&#123;      cout &lt;&lt; &quot;no contours are found .&quot; &lt;&lt; endl;      return res;  &#125;  RNG rng(0xFFFFFFFF);  res = Mat::zeros(img_thr.rows, img_thr.cols, CV_8UC3);  // calculate moments  vector&lt;Moments&gt; mu(contours.size());  for (int i = 0; i &lt; contours.size(); i++)  &#123;      mu[i] = moments(contours[i], false);  &#125;  // calculate centroids  vector&lt;Point2f&gt; mc(contours.size());  for (int i = 0; i &lt; contours.size(); i++)  &#123;      mc[i] = Point2d(mu[i].m10 / mu[i].m00, mu[i].m01 / mu[i].m00);  &#125;  for(auto i = 0; i &lt; contours.size(); i++)&#123;      drawContours(res, contours, i, randColor(rng));      putText(res, &quot;*&quot;, Point(mc[i].x, mc[i].y), FONT_HERSHEY_SIMPLEX, 0.4, Scalar(255, 0, 255), 1);  &#125;  return res;</code></pre><p>  }</p><p>  // helper function for readFolderAndExtractFeatures, preprocess image to binary image<br>  Mat preProcess(Mat img){</p><pre><code>  /*  @description  : preprocess img to denoise and remove light  @param  :       img : image to process  @Returns  :   */  if(img.channels() == 3)&#123;      cvtColor(img, img, COLOR_BGR2GRAY);  &#125;  Mat imgOut, imgNoise, imgLight;  medianBlur(img, imgNoise, 3);  imgNoise.copyTo(imgLight);  // read lightPat  Mat lightPat = imread(&quot;data/pattern.pgm&quot;, 0);  imgLight = removeLight(imgNoise, lightPat);  threshold(imgLight, imgOut, 30, 255, THRESH_BINARY);  return imgOut;</code></pre><p>  }</p><p>  // helper function for trainAndTest, readFolderAndExtractFeatures<br>  bool readFolderAndExtractFeatures(string filePath, int label, int numTest, </p><pre><code>  vector&lt;float&gt; &amp;trainingData, vector&lt;int&gt; &amp;trainResponses, vector&lt;float&gt; &amp;testData, vector&lt;int&gt; &amp;testResponses)&#123;  /*  @description  : read file data and extract area and aspect features  @param  :       filePath : image file path      label : image lable to classify      numTest : number for test      trainingData : trainingData feature: area, aspect      trainResponses : trainingData label      testData : testData feature: area, aspect      testResponses : testData label  @Returns  :       (ref return) : trainingData, trainResponses, testData, testResponses  */  vector&lt;String&gt; files;  // get folder  glob(filePath, files, true);   Mat frame;  int imgIdx = 0;  if(files.size() == 0)&#123;      return false;  &#125;  for(int i = 0; i &lt; files.size(); i++)&#123;      frame = imread(files[i]);      // preprocess image      Mat pre = preProcess(frame);      // get n features pair for each image      vector&lt;vector&lt;float&gt;&gt; features = extractFeatures(pre);      for(int i = 0; i &lt; features.size(); i++)&#123;          // first numTest for model test          if(imgIdx &gt;= numTest)&#123;              trainingData.push_back(features[i][0]);              trainingData.push_back(features[i][1]);              trainResponses.push_back(label);          &#125;else&#123;              testData.push_back(features[i][0]);              testData.push_back(features[i][1]);              testResponses.push_back(label);          &#125;      &#125;      imgIdx++;  &#125;  return true;</code></pre><p>  }</p><p>  // helper function for trainAndTest, ploat data error<br>  void plotData(Mat trainingDataMat, Mat trainResponsesMat, string mode, float* error){</p><pre><code>  /*  @description  : ploat train data feature (x: area, y: aspect) distributiion  @param  :       trainingDataMat : trainingDataMat shape [N/2, 2], N is trainData vector size      trainResponsesMat : trainResponsesMat shape [N, 1], N is trainData label vector size      error : total error rate to display  @Returns  :       None  */  float areaMax, areaMin, asMax, asMin;  areaMax = asMax = 0.0;  areaMin = asMin = 99999999;  for(int i = 0; i &lt; trainingDataMat.rows; i++)&#123;      float area = trainingDataMat.at&lt;float&gt;(i, 0);      float aspect = trainingDataMat.at&lt;float&gt;(i, 1);      // get min, max value      if(area &gt; areaMax)&#123;          areaMax = area;      &#125;      if(aspect &gt; asMax)&#123;          asMax = aspect;      &#125;      if(areaMin &gt; area)&#123;          areaMin = area;      &#125;      if(asMin &gt; area)&#123;          asMin = aspect;      &#125;  &#125;  // create image to display  Mat fig = Mat::zeros(512, 512, CV_8UC3);  for(int i = 0; i &lt; trainingDataMat.rows; i++)&#123;      float area = trainingDataMat.at&lt;float&gt;(i, 0);      float aspect = trainingDataMat.at&lt;float&gt;(i, 1);      // min-max norm [0~1] * 420 pixel      int x = (int)(420.0f*((area - areaMin) / (areaMax - areaMin)));      int y = (int)(420.0f*((aspect - asMin) / (asMax - asMin)));      int label = trainResponsesMat.at&lt;int&gt;(i);      Scalar color;      if(label == 0)&#123;          color = Scalar(255, 0, 0);      &#125;else if(label == 1)&#123;          color = Scalar(0, 255, 0);      &#125;else if(label == 2)&#123;          color = Scalar(0, 0, 255);      &#125;      // cicle locate with start at(80, 80) to overcome border      circle(fig, Point(x+80, y+80), 3, color, -1, 8);  &#125;  if(error != NULL)&#123;      stringstream ss;      ss &lt;&lt; mode &lt;&lt; &quot; error: &quot; &lt;&lt; *error &lt;&lt; &quot; \%&quot;;      putText(fig, ss.str(), Point(20, 512-40), FONT_HERSHEY_SIMPLEX, 0.75, Scalar(200, 200, 200), 1, LINE_AA);  &#125;  myWin-&gt;addImage(&quot;Fig&quot;, fig);</code></pre><p>  }</p><p>  void defineSVM(Ptr<SVM>&amp; svm){</SVM></p><pre><code>  /*  @description  : define svm parameters  @param  :       svm : svm model  @Returns  :       (ref return) : svm with parameters  */  svm = SVM::create();  svm-&gt;setType(SVM::C_SVC);  svm-&gt;setNu(0.05);  svm-&gt;setKernel(SVM::CHI2);  svm-&gt;setDegree(1.0);  svm-&gt;setGamma(2.0);  svm-&gt;setTermCriteria(TermCriteria(TermCriteria::MAX_ITER, 100, 1e-6));</code></pre><p>  }</p><p>  void trainSVM(){</p><pre><code>  /*  @description  : train a svm model and test its error rate  @param  :       mode : machine learning mode  @Returns  :       None  */  vector&lt;float&gt; trainingData;  vector&lt;int&gt; trainResponses;  vector&lt;float&gt; testData;  vector&lt;int&gt; testResponses;  int numTest = 20;  string nutPath = &quot;data/nut&quot;;  string ringPath = &quot;data/ring&quot;;  string screwPath = &quot;data/screw&quot;;  // read data path and extract feature  readFolderAndExtractFeatures(nutPath, 0, numTest, trainingData, trainResponses, testData, testResponses);  readFolderAndExtractFeatures(ringPath, 1, numTest, trainingData, trainResponses, testData, testResponses);  readFolderAndExtractFeatures(screwPath, 2, numTest, trainingData, trainResponses, testData, testResponses);  // cout &lt;&lt; &quot;Num of train samples: &quot; &lt;&lt; trainingData.size() &lt;&lt; endl;  // cout &lt;&lt; &quot;Num of test samples: &quot; &lt;&lt; testData.size() &lt;&lt; endl;  Mat trainingDataMat(trainingData.size() / 2, 2, CV_32FC1, &amp;trainingData[0]);  Mat trainResponsesMat(trainResponses.size(), 1, CV_32SC1, &amp;trainResponses[0]);  Mat testDataMat(testData.size() / 2, 2, CV_32FC1, &amp;testData[0]);  Mat testResponsesMat(testResponses.size(), 1, CV_32SC1, &amp;testResponses[0]);  // set row sample  Ptr&lt;TrainData&gt; tData = TrainData::create(trainingDataMat, ROW_SAMPLE, trainResponsesMat);  // select model  Ptr&lt;SVM&gt; model = SVM::create();  defineSVM(model);  model-&gt;train(tData);  model-&gt;save(&quot;model/svm.xml&quot;);  if(testResponses.size() &gt; 0)&#123;      Mat testPredict;      // predict      model-&gt;predict(testDataMat, testPredict);      testPredict.convertTo(testPredict, CV_32SC1);      Mat errMat = testPredict != testResponsesMat;      float error = 100.0f * countNonZero(errMat) / testResponses.size();      cout &lt;&lt; &quot;svm&quot; &lt;&lt; &quot; Error rate: &quot; &lt;&lt; error &lt;&lt; &quot;\%&quot; &lt;&lt; endl;      plotData(trainingDataMat, trainResponsesMat, &quot;svm&quot;, &amp;error);  &#125;  else&#123;      plotData(trainingDataMat, trainResponsesMat, &quot;svm&quot;);  &#125;</code></pre><p>  }</p><p>  vector&lt;vector<float>&gt; extractFeatures(Mat img, vector<int>* posLeft, vector<int>* posTop){</int></int></float></p><pre><code>  /*  @description  : extract image features and get left top loation  @param  :       img : image to get feature      postLeft : left top_left location      postTop : top top_left location  @Returns  :       features: extracted feature  */  vector&lt;vector&lt;float&gt;&gt; features;  vector&lt;vector&lt;Point&gt;&gt; contours;  vector&lt;Vec4i&gt; hierarchy;  Mat temp = img.clone();  // find contours  findContours(temp, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);  if(contours.size() == 0)&#123;      return features;  &#125;  for(int i = 0; i &lt; contours.size(); i++)&#123;      Mat mask = Mat::zeros(img.rows, img.cols, CV_8UC1);      // draw contours      drawContours(mask, contours, i, Scalar(1), FILLED, LINE_8, hierarchy, 1);      // get area value      Scalar areaSum = sum(mask);      float area = areaSum[0];      if(area &gt; 500)&#123;          // calculate aspect for area is larger than 500          RotatedRect r = minAreaRect(contours[i]);          float w = r.size.width;          float h = r.size.height;          float aspect = w &lt; h ? h / w : w / h;          vector&lt;float&gt; row;          // load calculated feature          row.push_back(area);          row.push_back(aspect);          features.push_back(row);          // load top_left location          if(posLeft != NULL)&#123;              posLeft-&gt;push_back((int)r.center.x);          &#125;          if(posTop != NULL)&#123;              posTop-&gt;push_back((int)r.center.y);          &#125;          myWin-&gt;addImage(&quot;Extracted Feature&quot;, mask * 255);          myWin-&gt;render();          waitKey(10);      &#125;  &#125;  return features;</code></pre><p>  }</p><p>  /*<br>  @File          :utils.inl<br>  @Description:  :<br>  @Date          :2021/12/25 20:29:26<br>  @Author        :xieyin<br>  @version       :1.0<br>  */<br>  template<typename t><br>  void trainAndTest(string mode){</typename></p><pre><code>  /*  @description  : train a svm model and test its error rate  @param  :       mode : machine learning mode  @Returns  :       None  */  vector&lt;float&gt; trainingData;  vector&lt;int&gt; trainResponses;  vector&lt;float&gt; testData;  vector&lt;int&gt; testResponses;  int numTest = 20;  string nutPath = &quot;data/nut&quot;;  string ringPath = &quot;data/ring&quot;;  string screwPath = &quot;data/screw&quot;;  // read data path and extract feature  readFolderAndExtractFeatures(nutPath, 0, numTest, trainingData, trainResponses, testData, testResponses);  readFolderAndExtractFeatures(ringPath, 1, numTest, trainingData, trainResponses, testData, testResponses);  readFolderAndExtractFeatures(screwPath, 2, numTest, trainingData, trainResponses, testData, testResponses);  // cout &lt;&lt; &quot;Num of train samples: &quot; &lt;&lt; trainingData.size() &lt;&lt; endl;  // cout &lt;&lt; &quot;Num of test samples: &quot; &lt;&lt; testData.size() &lt;&lt; endl;  Mat trainingDataMat(trainingData.size() / 2, 2, CV_32FC1, &amp;trainingData[0]);  Mat trainResponsesMat(trainResponses.size(), 1, CV_32SC1, &amp;trainResponses[0]);  Mat testDataMat(testData.size() / 2, 2, CV_32FC1, &amp;testData[0]);  Mat testResponsesMat(testResponses.size(), 1, CV_32SC1, &amp;testResponses[0]);  // set row sample  Ptr&lt;TrainData&gt; tData = TrainData::create(trainingDataMat, ROW_SAMPLE, trainResponsesMat);  // select model  Ptr&lt;T&gt; model = T::create();  model-&gt;train(tData);  model-&gt;save(&quot;model/&quot; + mode + &quot;.xml&quot;);  if(testResponses.size() &gt; 0)&#123;      Mat testPredict;      // predict      model-&gt;predict(testDataMat, testPredict);      testPredict.convertTo(testPredict, CV_32SC1);      Mat errMat = testPredict != testResponsesMat;      float error = 100.0f * countNonZero(errMat) / testResponses.size();      cout &lt;&lt; mode &lt;&lt; &quot; Error rate: &quot; &lt;&lt; error &lt;&lt; &quot;\%&quot; &lt;&lt; endl;      plotData(trainingDataMat, trainResponsesMat, mode, &amp;error);  &#125;  else&#123;      plotData(trainingDataMat, trainResponsesMat, mode);  &#125;</code></pre><p>  }</p><p>  template<typename t><br>  void predict(vector&lt;vector<float>&gt; features, vector<int> posLeft, vector<int> posTop, string mode, Mat&amp; imgOut){</int></int></float></typename></p><pre><code>  /*  @description  : predict features extracted from imgOut, and put text in left top position  @param  :       features : extracted feature from imgOut      posLeft : left_top left location      posTop : left_top top location      mode : machine learning mode      imgOut : the img with text output  @Returns  :       (ref return) : imgOut  */  for(int i = 0; i &lt; features.size(); i++)&#123;      Mat predDataMat(1, 2, CV_32FC1, &amp;features[i][0]);      Ptr&lt;T&gt; model = Algorithm::load&lt;T&gt;(&quot;model/&quot; + mode + &quot;.xml&quot;);      float result = model-&gt;predict(predDataMat);      cout &lt;&lt; result &lt;&lt; endl;      stringstream ss;      Scalar color;      if(result == 0)&#123;          color = Scalar(255, 0, 0);          ss &lt;&lt; &quot;NUT&quot;;      &#125;      else if(result == 1)&#123;          color = Scalar(0, 255, 0);          ss &lt;&lt; &quot;RING&quot;;      &#125;      else if(result == 2)&#123;          color = Scalar(0, 255, 0);          ss &lt;&lt; &quot;SCREW&quot;;      &#125;      putText(imgOut, ss.str(), Point2d(posLeft[i], posTop[i]), FONT_HERSHEY_SIMPLEX, 0.4, color);  &#125;</code></pre><p>  }</p><p>  3）主函数</p><p>  /*<br>  @File          :main.cpp<br>  @Description:  :<br>  @Date          :2021/12/25 09:23:30<br>  @Author        :xieyin<br>  @version       :1.0<br>  */</p><p>  #include<iostream><br>  #include<string><br>  #include<sstream><br>  #include<memory><br>  using namespace std;</memory></sstream></string></iostream></p><p>  #include&lt;opencv2/core.hpp&gt;<br>  #include&lt;opencv2/highgui.hpp&gt;<br>  #include&lt;opencv2/imgproc.hpp&gt;<br>  #include&lt;opencv2/opencv.hpp&gt;<br>  #include&lt;opencv2/ml.hpp&gt;<br>  using namespace cv;<br>  using namespace cv::ml;</p><p>  #include”mwindow.hpp”<br>  #include”utils.hpp”</p><p>  const char* keys = {</p><pre><code>  &quot;&#123;help h usage ? | | Print this message&#125;&quot;  &quot;&#123;@image | | Image for test&#125;&quot;  &quot;&#123;@lightPat | | light pattern for test image&#125;&quot;  &quot;&#123;@mode | svm | machine learning mode, default svm&#125;&quot;</code></pre><p>  };</p><p>  shared_ptr<MWindow> myWin;</MWindow></p><p>  int main(int argc, const char** argv){</p><pre><code>  // command line parser  CommandLineParser parser(argc, argv, keys);  if(parser.has(&quot;help&quot;))&#123;      parser.printMessage();      return 0;  &#125;  if(!parser.check())&#123;      parser.printErrors();      return 0;  &#125;  // define mywin  myWin = make_shared&lt;MWindow&gt;(&quot;Main Window&quot;, 2, 2, 700, 1000, 1);    // get test image path  String imgFile = parser.get&lt;String&gt;(0);   Mat img = imread(imgFile, 0);  if(img.data == NULL)&#123;      cout &lt;&lt; &quot;can not read image file.&quot; &lt;&lt; endl;      return 0;  &#125;  // get light pattern image  String ligPatFile = parser.get&lt;String&gt;(1);  Mat lightPat = imread(ligPatFile, 0);  if(lightPat.data == NULL)&#123;      cout &lt;&lt; &quot;can not read image file.&quot; &lt;&lt; endl;      return 0;  &#125;  // mdeianblur light pattern  medianBlur(lightPat, lightPat, 3);  // copy img to imgOut  Mat imgOut = img.clone();  cvtColor(imgOut, imgOut, COLOR_GRAY2BGR);  // preprocess image  Mat pre = preProcess(img);  // get feature and top left location from image  vector&lt;int&gt; posLeft, posTop;  vector&lt;vector&lt;float&gt;&gt; features = extractFeatures(pre, &amp;posLeft, &amp;posTop);  // get mode selection  string mode = parser.get&lt;string&gt;(2);  // train and predict model  if (mode == &quot;svm&quot;)&#123;      trainSVM();      // trainAndTest&lt;SVM&gt;(mode);      predict&lt;SVM&gt;(features, posLeft, posTop, mode, imgOut);  &#125;  else if (mode == &quot;bayes&quot;)&#123;      trainAndTest&lt;NormalBayesClassifier&gt;(mode);      predict&lt;NormalBayesClassifier&gt;(features, posLeft, posTop, mode, imgOut);  &#125;  else if(mode == &quot;boost&quot;)&#123;      trainAndTest&lt;Boost&gt;(mode);      predict&lt;Boost&gt;(features, posLeft, posTop, mode, imgOut);  &#125;  else&#123;      cout &lt;&lt; &quot;not support model&quot;;      return 0;  &#125;  myWin-&gt;addImage(&quot;binary Image&quot;, pre);  myWin-&gt;addImage(&quot;result&quot;, imgOut);  myWin-&gt;render();  waitKey(0);  return 0;</code></pre><p>  }</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;题目要求：在上一章&lt;a href=&quot;https://blog.csdn.net/qq_37172182/article/details/122088583&quot;&gt;OpenCV—-简单目标提取和分割&lt;/a&gt;中尝试使用opencv连</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指OFFER系列之51----数组中的逆序对</title>
    <link href="http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B51----%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://example.com/2022/01/19/%E5%89%91%E6%8C%87OFFER%E7%B3%BB%E5%88%97%E4%B9%8B51----%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</id>
    <published>2022-01-19T14:59:33.203Z</published>
    <updated>2022-01-19T15:01:37.362Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="剑指OFFER"><a href="#剑指OFFER" class="headerlink" title="剑指OFFER"></a>剑指OFFER</h3><blockquote><p>题目描述：在一个数组中，如果前一个数字大于后面的数字， 则这两个数字组成一个逆序对。输入一个数组，求该数组中逆序对的个数。</p></blockquote><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;climits&gt;#include&lt;unordered_map&gt;using namespace std;int reversePairs(vector&lt;int&gt;&amp; nums, int left, int right, vector&lt;int&gt;&amp; temp)&#123;    if(left &gt;= right)&#123;        return 0;    &#125;    int ans = 0, mid = (left + right) / 2;    ans += reversePairs(nums, left, mid, temp);    ans += reversePairs(nums, mid + 1, right, temp);    int i = left, j = mid + 1, k = 0;    while(i &lt;= m &amp;&amp; j &lt;= right)&#123;        if(nums[i] &lt;= nums[j])&#123;            temp[k++] = nums[i++];        &#125;else&#123;            temp[k++] = nums[j++];            ans += mid - i + 1;        &#125;    &#125;    while(i &lt;= m)&#123;        temp[k++] = nums[i++];    &#125;    while(j &lt;= right)&#123;        temp[k++] = nums[j++];    &#125;    for(int i = left, k = 0; i &lt;= right; i++)&#123;        nums[i] = temp[k++];    &#125;    return ans;&#125;int reversePairs(vector&lt;int&gt;&amp; nums)&#123;    int n = nums.size();    if(n &lt; 2)&#123;        return 0;    &#125;    vector&lt;int&gt; temp(n, 0);    return reversePairs(nums, 0, n - 1, temp);&#125;void utils()&#123;    cout &lt;&lt; &quot;enter nums: &quot;;    int val;    vector&lt;int&gt; nums;    cin &gt;&gt; val;    nums.push_back(val);    cout &lt;&lt; &quot;reversePairs: &quot; &lt;&lt; reversePairs(nums) &lt;&lt; endl;&#125;int main()&#123;    utils();    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;剑指OFFER&quot;&gt;&lt;a href=&quot;#剑指OFFER&quot; class=&quot;headerlink&quot; title=&quot;剑指OFFER&quot;&gt;&lt;/a&gt;剑指OFFER&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：在一个数组中，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VSCode配置之Opencv4x终极奥义</title>
    <link href="http://example.com/2022/01/19/VSCode%E9%85%8D%E7%BD%AE%E4%B9%8BOpencv4x%E7%BB%88%E6%9E%81%E5%A5%A5%E4%B9%89/"/>
    <id>http://example.com/2022/01/19/VSCode%E9%85%8D%E7%BD%AE%E4%B9%8BOpencv4x%E7%BB%88%E6%9E%81%E5%A5%A5%E4%B9%89/</id>
    <published>2022-01-19T14:59:33.143Z</published>
    <updated>2022-01-19T15:01:36.558Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>苦于windows下编译opencv的效率和对于大型软件如Visual Studio 2017、Visual Studio S2019等的不习惯，希望VScode也能够快速、高效编译第三方库，如opencv等，花了大概两天的时间，分析了主流的方法，最终适配出了一套极简方案：<strong>opencv4x终极奥义</strong></p><ul><li>  支持CMakeLists.txt编写自己的opencv项目</li><li>  支持Release和Debug两种模式运行，其中Debug速度较Release慢；</li><li>  支持多级文件访问和子目录CMakeLists.txt编译</li><li>  无需多余cmake、vscode配置，all in CMakeLists.txt</li><li>  简言之，一款windows下的cmake极简配置</li></ul><p>工具准备：<br>opencv4.5.4下载：<a href="https://sourceforge.net/projects/opencvlibrary/files/4.5.4/opencv-4.5.4-vc14_vc15.exe/download">opencv-4.5.4-vc14_vc15.exe</a><br>cmake（仅仅下载安装，无需GUI）<br>Visual Studio Pro 2017(仅下载，便于支持加速编译)<br>添加环境变量：path\to\opencv\build\x64\vc15\bin<br>添加path\to\opencv\build\x64\vc15\lib下：opencv_world454.dll和opencv_world454d.dll到C:/Windows/System32中</p><p>方法：<br>step1 ：VScode中安装插件CMake和CMake Tools,其强大之处在于保存即编译；<br>使用方法：</p><pre><code>Ctrl + shift + P 输入CMake: Quick Start 生成CMakeLists.txt模板</code></pre><p><img src="https://img-blog.csdnimg.cn/8b65988008314d8c8a73478b9e6094f8.png" alt="最佳配置选项"><br>step2: 编写自己的CMakeLists.txt内容。这里以opencv自带示例asift.cpp为例，该方法匹配两张图像（有旋转）的特征点。</p><pre><code># cmake needs this linecmake_minimum_required(VERSION 3.1)SET(CMAKE_BUILD_TYPE &quot;Release&quot;)# Define project nameproject(opencv_example_project)include_directories(&quot;D:/Downloads/opencv/build/include&quot; &quot;D:/Downloads/opencv/build/include/opencv2&quot;)#指定dll的lib所在路径link_directories(&quot;D:/Downloads/opencv/build/x64/vc15/lib&quot;)# 将源代码添加到此项目的可执行文件。add_executable (asift asift.cpp)#指定链接库的名字，即该dll#opencv_410d.lib在\path\to\opencv\build\x64\vc15\lib目录下target_link_libraries(asift opencv_world454)</code></pre><p>【注】：最后选择target_link_libraries时，根据CMake编译方法不同而不同，Release版本使用opencv_world454，Debug版本使用opencv_world454<br>step3:编译运行<br>截图从左到右一次进过cmake,build,最后run。<br><img src="https://img-blog.csdnimg.cn/6a008187465f4f5e825e2a186ca47f6c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfMzcxNzIxODI=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>step4: 代码与效果展示</p><pre><code>// main.cpp#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/features2d.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/calib3d.hpp&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;using namespace cv;static void help(char** argv)&#123;    cout    &lt;&lt; &quot;This is a sample usage of AffineFeature detector/extractor.\n&quot;    &lt;&lt; &quot;And this is a C++ version of samples/python/asift.py\n&quot;    &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot;\n&quot;    &lt;&lt; &quot;     [ --feature=&lt;sift|orb|brisk&gt; ]         # Feature to use.\n&quot;    &lt;&lt; &quot;     [ --flann ]                            # use Flann-based matcher instead of bruteforce.\n&quot;    &lt;&lt; &quot;     [ --maxlines=&lt;number(50 as default)&gt; ] # The maximum number of lines in visualizing the matching result.\n&quot;    &lt;&lt; &quot;     [ --image1=&lt;image1(aero1.jpg as default)&gt; ]\n&quot;    &lt;&lt; &quot;     [ --image2=&lt;image2(aero3.jpg as default)&gt; ] # Path to images to compare.&quot;    &lt;&lt; endl;&#125;static double timer()&#123;    return getTickCount() / getTickFrequency();&#125;int main(int argc, char** argv)&#123;    vector&lt;String&gt; fileName;    cv::CommandLineParser parser(argc, argv,        &quot;&#123;help h ||&#125;&quot;        &quot;&#123;feature|brisk|&#125;&quot;        &quot;&#123;flann||&#125;&quot;        &quot;&#123;maxlines|50|&#125;&quot;        &quot;&#123;image1|aero1.jpg|&#125;&#123;image2|aero3.jpg|&#125;&quot;);    if (parser.has(&quot;help&quot;))    &#123;        help(argv);        return 0;    &#125;    string feature = parser.get&lt;string&gt;(&quot;feature&quot;);    bool useFlann = parser.has(&quot;flann&quot;);    int maxlines = parser.get&lt;int&gt;(&quot;maxlines&quot;);    fileName.push_back(samples::findFile(parser.get&lt;string&gt;(&quot;image1&quot;)));    fileName.push_back(samples::findFile(parser.get&lt;string&gt;(&quot;image2&quot;)));    if (!parser.check())    &#123;        parser.printErrors();        cout &lt;&lt; &quot;See --help (or missing &#39;=&#39; between argument name and value?)&quot; &lt;&lt; endl;        return 1;    &#125;    Mat img1 = imread(fileName[0], IMREAD_GRAYSCALE);    Mat img2 = imread(fileName[1], IMREAD_GRAYSCALE);    if (img1.empty())    &#123;        cerr &lt;&lt; &quot;Image &quot; &lt;&lt; fileName[0] &lt;&lt; &quot; is empty or cannot be found&quot; &lt;&lt; endl;        return 1;    &#125;    if (img2.empty())    &#123;        cerr &lt;&lt; &quot;Image &quot; &lt;&lt; fileName[1] &lt;&lt; &quot; is empty or cannot be found&quot; &lt;&lt; endl;        return 1;    &#125;    Ptr&lt;Feature2D&gt; backend;    Ptr&lt;DescriptorMatcher&gt; matcher;    if (feature == &quot;sift&quot;)    &#123;        backend = SIFT::create();        if (useFlann)            matcher = DescriptorMatcher::create(&quot;FlannBased&quot;);        else            matcher = DescriptorMatcher::create(&quot;BruteForce&quot;);    &#125;    else if (feature == &quot;orb&quot;)    &#123;        backend = ORB::create();        if (useFlann)            matcher = makePtr&lt;FlannBasedMatcher&gt;(makePtr&lt;flann::LshIndexParams&gt;(6, 12, 1));        else            matcher = DescriptorMatcher::create(&quot;BruteForce-Hamming&quot;);    &#125;    else if (feature == &quot;brisk&quot;)    &#123;        backend = BRISK::create();        if (useFlann)            matcher = makePtr&lt;FlannBasedMatcher&gt;(makePtr&lt;flann::LshIndexParams&gt;(6, 12, 1));        else            matcher = DescriptorMatcher::create(&quot;BruteForce-Hamming&quot;);    &#125;    else    &#123;        cerr &lt;&lt; feature &lt;&lt; &quot; is not supported. See --help&quot; &lt;&lt; endl;        return 1;    &#125;    cout &lt;&lt; &quot;extracting with &quot; &lt;&lt; feature &lt;&lt; &quot;...&quot; &lt;&lt; endl;    Ptr&lt;AffineFeature&gt; ext = AffineFeature::create(backend);    vector&lt;KeyPoint&gt; kp1, kp2;    Mat desc1, desc2;    ext-&gt;detectAndCompute(img1, Mat(), kp1, desc1);    ext-&gt;detectAndCompute(img2, Mat(), kp2, desc2);    cout &lt;&lt; &quot;img1 - &quot; &lt;&lt; kp1.size() &lt;&lt; &quot; features, &quot;         &lt;&lt; &quot;img2 - &quot; &lt;&lt; kp2.size() &lt;&lt; &quot; features&quot;         &lt;&lt; endl;    cout &lt;&lt; &quot;matching with &quot; &lt;&lt; (useFlann ? &quot;flann&quot; : &quot;bruteforce&quot;) &lt;&lt; &quot;...&quot; &lt;&lt; endl;    double start = timer();    // match and draw    vector&lt; vector&lt;DMatch&gt; &gt; rawMatches;    vector&lt;Point2f&gt; p1, p2;    vector&lt;float&gt; distances;    matcher-&gt;knnMatch(desc1, desc2, rawMatches, 2);    // filter_matches    for (size_t i = 0; i &lt; rawMatches.size(); i++)    &#123;        const vector&lt;DMatch&gt;&amp; m = rawMatches[i];        if (m.size() == 2 &amp;&amp; m[0].distance &lt; m[1].distance * 0.75)        &#123;            p1.push_back(kp1[m[0].queryIdx].pt);            p2.push_back(kp2[m[0].trainIdx].pt);            distances.push_back(m[0].distance);        &#125;    &#125;    vector&lt;uchar&gt; status;    vector&lt; pair&lt;Point2f, Point2f&gt; &gt; pointPairs;    Mat H = findHomography(p1, p2, status, RANSAC);    int inliers = 0;    for (size_t i = 0; i &lt; status.size(); i++)    &#123;        if (status[i])        &#123;            pointPairs.push_back(make_pair(p1[i], p2[i]));            distances[inliers] = distances[i];            // CV_Assert(inliers &lt;= (int)i);            inliers++;        &#125;    &#125;    distances.resize(inliers);    cout &lt;&lt; &quot;execution time: &quot; &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; (timer()-start)*1000 &lt;&lt; &quot; ms&quot; &lt;&lt; endl;    cout &lt;&lt; inliers &lt;&lt; &quot; / &quot; &lt;&lt; status.size() &lt;&lt; &quot; inliers/matched&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;visualizing...&quot; &lt;&lt; endl;    vector&lt;int&gt; indices(inliers);    cv::sortIdx(distances, indices, SORT_EVERY_ROW+SORT_ASCENDING);    // explore_match    int h1 = img1.size().height;    int w1 = img1.size().width;    int h2 = img2.size().height;    int w2 = img2.size().width;    Mat vis = Mat::zeros(max(h1, h2), w1+w2, CV_8U);    img1.copyTo(Mat(vis, Rect(0, 0, w1, h1)));    img2.copyTo(Mat(vis, Rect(w1, 0, w2, h2)));    cvtColor(vis, vis, COLOR_GRAY2BGR);    vector&lt;Point2f&gt; corners(4);    corners[0] = Point2f(0, 0);    corners[1] = Point2f((float)w1, 0);    corners[2] = Point2f((float)w1, (float)h1);    corners[3] = Point2f(0, (float)h1);    vector&lt;Point2i&gt; icorners;    perspectiveTransform(corners, corners, H);    transform(corners, corners, Matx23f(1,0,(float)w1,0,1,0));    Mat(corners).convertTo(icorners, CV_32S);    polylines(vis, icorners, true, Scalar(255,255,255));    for (int i = 0; i &lt; min(inliers, maxlines); i++)    &#123;        int idx = indices[i];        const Point2f&amp; pi1 = pointPairs[idx].first;        const Point2f&amp; pi2 = pointPairs[idx].second;        circle(vis, pi1, 2, Scalar(0,255,0), -1);        circle(vis, pi2 + Point2f((float)w1,0), 2, Scalar(0,255,0), -1);        line(vis, pi1, pi2 + Point2f((float)w1,0), Scalar(0,255,0));    &#125;    if (inliers &gt; maxlines)        cout &lt;&lt; &quot;only &quot; &lt;&lt; maxlines &lt;&lt; &quot; inliers are visualized&quot; &lt;&lt; endl;    imshow(&quot;affine find_obj&quot;, vis);    // Mat vis2 = Mat::zeros(max(h1, h2), w1+w2, CV_8U);    // Mat warp1;    // warpPerspective(img1, warp1, H, Size(w1, h1));    // warp1.copyTo(Mat(vis2, Rect(0, 0, w1, h1)));    // img2.copyTo(Mat(vis2, Rect(w1, 0, w2, h2)));    // imshow(&quot;warped&quot;, vis2);    waitKey();    cout &lt;&lt; &quot;done&quot; &lt;&lt; endl;    return 0;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/0f1d1a5fef6f4fa0b43275893d5f688e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfMzcxNzIxODI=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="效果图"></p><p>对比：</p><ol><li><p> 在Vistual Studio2019中设置属性，手动添加源文件等，一次设置多次可用，唯一的缺点是软件过大，修改比较麻烦</p></li><li><p> 在VScode中改变C++的参数命令，自动添加 -I -L等库文件包，需要改变task,lunch等yaml文件，使用的是mingw64编译，速度较慢（实测）</p></li><li><p>使用Cmake编译opencv,将CMakelists.txt的kit selecti设置为mingw64，可行但速度慢，相关配置如下：（可能出现无法定位程序输入点问题，将mingw64下bin/libstdc+±6.dll放置在C:/Windows/System32中）</p><h1 id="CMakeList-txt-CMakeProject1-的-CMake-项目，在此处包括源代码并定义"><a href="#CMakeList-txt-CMakeProject1-的-CMake-项目，在此处包括源代码并定义" class="headerlink" title="CMakeList.txt: CMakeProject1 的 CMake 项目，在此处包括源代码并定义"></a>CMakeList.txt: CMakeProject1 的 CMake 项目，在此处包括源代码并定义</h1><h1 id="项目特定的逻辑。"><a href="#项目特定的逻辑。" class="headerlink" title="项目特定的逻辑。"></a>项目特定的逻辑。</h1><h1 id><a href="#" class="headerlink" title></a></h1><p> cmake_minimum_required (VERSION 3.8)<br> set(CMAKE_BUILD_TYPE “Release”)<br> project (“imgShow”)<br> #指定要引用的dll的头文件所在路径，即为文件夹opencv2的路径，<br> #dll的头文件地址前半部分（”D:\Tool&quot;）需根据opencv安装的位置确定。<br> include_directories(“D:/Downloads/opencv/build/x64/mingw/install/include” “D:/Downloads/opencv/build/x64/mingw/install/include/opencv2”)<br> #指定dll的lib所在路径<br> link_directories(“D:/Downloads/opencv/build/x64/mingw/lib”)</p><h1 id="将源代码添加到此项目的可执行文件。"><a href="#将源代码添加到此项目的可执行文件。" class="headerlink" title="将源代码添加到此项目的可执行文件。"></a>将源代码添加到此项目的可执行文件。</h1><p> add_executable (asift asift.cpp)</p><p> #指定链接库的名字，即该dll<br>  target_link_libraries(asift<br>  “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_calib3d454.dll”<br>  “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_core454.dll”<br>  “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_dnn454.dll”<br>  “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_features2d454.dll”<br>  “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_flann454.dll”<br>  “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_gapi454.dll”<br>  “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_highgui454.dll”<br>  “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_imgcodecs454.dll”<br>  “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_imgproc454.dll”<br>  “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_ml454.dll”<br>  “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_objdetect454.dll”<br>  “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_photo454.dll”<br>  “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_stitching454.dll” “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_video454.dll”<br>  “D:/Downloads/opencv/build/x64/mingw/bin/libopencv_videoio454.dll” )</p><h1 id="TODO-如有需要，请添加测试并安装目标。"><a href="#TODO-如有需要，请添加测试并安装目标。" class="headerlink" title="TODO: 如有需要，请添加测试并安装目标。"></a>TODO: 如有需要，请添加测试并安装目标。</h1></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;苦于windows下编译opencv的效率和对于大型软件如Visual Studio 2017、Visual Studio S2019等的不习惯，希望VScode也能够快速、高效编译第三方库，如opencv等，花了大概两天的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++高级编程----模板的高级特性</title>
    <link href="http://example.com/2022/01/19/C++%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B----%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2022/01/19/C++%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B----%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</id>
    <published>2022-01-19T14:59:32.975Z</published>
    <updated>2022-01-19T15:01:36.558Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>题目要求：假设有一个Grid类，定义了一个网格的的大小（mWidth, mHeight），每个网格对于一个值（value）,这个值可能是int,double,string等类型；存储整个网格的数据结构可以是vector,可以是deque，可以提供默认初始值；可以支持二维、三维拓展；对于其中的一些函数，希望支持变长参数控制，支持元组类型的打印控制；</p><blockquote><p>分析：<br>1）支持Grid&lt;int, vector&gt;, Grid&lt;int, deque&gt;, Grid，容器模板类编程支持vector、deque和默认为vector，定义temple&lt;typename T, typename Container = std::vector&gt;，支持简化版Grid&lt;int, vector&gt;，定义template&lt;typename T, template&lt;typename E, typename Allocator = std::allocator&gt; class Container = std::vector&gt;；</p><p>2）支持Grid默认填充0，Grid&lt;int, 10&gt;默认填充10,支持Grid&lt;classA, objA&gt;定义 template&lt;typename T, const T&amp; DEFAULT&gt;</p><p>3）支持多维数据Grid[x][y] = z,Grid[i][j][k] = r等,定义循环递归类NDGrid&lt;typename T, size_t N-1&gt;,定义基本条件(模板特例化)：template class NDGrid&lt;T, 1&gt;;<br>4) 变长参数控制函数processValue(1, 2, 3.56, “test”, 1.1f)，考虑非const引用和左值引用，设计template&lt;typename T1, typename … Tn&gt; + std::forward(args…)方法；</p><p>5）支持打印auto t1 = make_tuple(1, 2, 3.56, “test”, 1.1f); tuple_print(t1)，打印元组，定义tuple_print_helper&lt;n - 1, TupleType&gt; tp(t)和tuple_print_helper&lt;0, TupleType&gt;类递归打印元组各个值</p></blockquote><p>方法实现和测试<br>分析1：实现容器模板和默认容器填充、容器Allocator</p><pre><code>// case 1:/*@File          :grid.h@Description:  :template gird support vector/dequeue container@Date          :2021/12/04 15:22:35@Author        :    @version       :1.0*/#pragma once#include&lt;vector&gt;// 1: basic version: // template&lt;typename T, typename Container&gt;// 2:  template defalut, add default container for Grid class// template&lt;typename T, typename Container = std::vector&lt;T&gt;&gt;// 3: template template, support Grid&lt;int, vector&gt;, not only Grid&lt;int, vector&lt;int&gt;&gt;template&lt;typename T, template&lt;typename E, typename Allocator = std::allocator&lt;E&gt;&gt; class Container = std::vector&gt;class Grid&#123;   public:       // constructor       explicit Grid(size_t inWidth= kDefaultWidth, size_t inHeight = kDefaultHeight);              // set value at (x, y)       void setElement(size_t x, size_t y, const T&amp; inElem);              // get value at (x, y)       T&amp; getElement(size_t x, size_t y);       const T&amp; getElement(size_t x, size_t y) const;              // get grid size with width and height       size_t getWidth() const&#123;return mWidth;&#125;       size_t getHeight() const&#123;return mHeight;&#125;       // set default size       static const size_t kDefaultWidth = 10;       static const size_t kDefaultHeight = 10;   private:   void initalizeCellsContainer();   // 2: std::vector&lt;Container&gt; mCells   std::vector&lt;Container&lt;T&gt;&gt; mCells;   size_t mWidth, mHeight;&#125;;// 2: template defalut// template&lt;typename T, typename Container&gt;// 3: template parmeter for templatetemplate&lt;typename T, template&lt;typename E, typename Allocator = std::allocator&lt;E&gt;&gt; class Container&gt;Grid&lt;T, Container&gt;::Grid(size_t inWidth, size_t inHeight):mWidth(inWidth), mHeight(inHeight)&#123;   initalizeCellsContainer();&#125;template&lt;typename T, template&lt;typename E, typename Allocator = std::allocator&lt;E&gt;&gt; class Container&gt;void Grid&lt;T, Container&gt;::setElement(size_t x, size_t y, const T&amp; inElem)&#123;    /*    @description  : set element at (x, y) with value inElem     @param  : location (x, y)    @Returns  : None     */    mCells[x][y] = inElem;&#125;template&lt;typename T, template&lt;typename E, typename Allocator = std::allocator&lt;E&gt;&gt; class Container&gt;T&amp; Grid&lt;T, Container&gt;::getElement(size_t x, size_t y)&#123;   /*   @description  : get element at (x, y)   @param  : location (x, y)   @Returns  : value at (x, y)   */   return mCells[x][y];&#125;template&lt;typename T, template&lt;typename E, typename Allocator = std::allocator&lt;E&gt;&gt; class Container&gt;const T&amp; Grid&lt;T, Container&gt;::getElement(size_t x, size_t y) const&#123;   /*   @description  : get const version element at (x, y)    @param  : location (x, y)   @Returns  : const value at (x, y)   */   return mCells[x][y];&#125;template&lt;typename T, template&lt;typename E, typename Allocator = std::allocator&lt;E&gt;&gt; class Container&gt;void Grid&lt;T, Container&gt;::initalizeCellsContainer()&#123;   /*   @description  : initalize cells container helper to resize container    @param  : None   @Returns  : None   */   mCells.resize(mWidth);   for(auto&amp; col : mCells)&#123;       col.resize(mHeight);   &#125;&#125;// main /#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;deque&gt;#include&quot;gridContainer.h&quot;using namespace std;int main()&#123;   // ----------------- test case 1 --------------------------//   // // Grid&lt;T, Constainer&gt;   // Grid&lt;int, vector&lt;int&gt;&gt; myVectorGrid;   // Grid&lt;int, deque&lt;int&gt;&gt; myDequeGrid;      // myVectorGrid.setElement(1, 2, 3);   // cout &lt;&lt; myVectorGrid.getElement(1, 2) &lt;&lt; endl;   // myDequeGrid.setElement(0, 0, 3);   // cout &lt;&lt; myDequeGrid.getElement(0, 0) &lt;&lt; endl;   // Grid&lt;int, vector&lt;int&gt;&gt; myVectorGrid2(myVectorGrid);   // cout &lt;&lt; myVectorGrid2.getElement(1,2);   //error type: Grid&lt;int, int&gt; since the second template typename does not have the method resize() in initalizeCellsContainer()      // ----------------- test case 2 --------------------------//   Grid&lt;int&gt; myVectorDefault;  //Grid&lt;int, vector&lt;int&gt;&gt;    // ----------------- test case 3 --------------------------//   Grid&lt;int, vector&gt; myVectorGrid;   myVectorGrid.setElement(1, 2, 3);   cout &lt;&lt; myVectorGrid.getElement(1, 2) &lt;&lt; endl;   return 0;&#125;</code></pre><p>分析2：实现默认值填充</p><pre><code>#pragma once#include&lt;vector&gt;// non-typename only support: int, enum, pointer, reference// template&lt;typename T, const T DEFAULT = T()&gt;// reference template for other classtemplate&lt;typename T, const T&amp; DEFAULT&gt;class Grid&#123;    public:        explicit Grid(size_t inWidth = kDefaultWidht, size_t inHeight = kDefaultHeight);        // setter        void setElement(size_t x, size_t y, const T&amp; inElem);        // getter        T&amp; getElement(size_t x, size_t y);        const T&amp; getElement(size_t x, size_t y) const;        size_t getWidth() const &#123;return mWidth;&#125;        size_t getHeight() const &#123;return mHeight;&#125;        static const size_t kDefaultWidht = 10;        static const size_t kDefaultHeight = 10;    private:        size_t mWidth;        size_t mHeight;        std::vector&lt;std::vector&lt;T&gt;&gt; mCells;        void initalizeCellsContainer();&#125;;template&lt;typename T, const T&amp; DEFAULT&gt;Grid&lt;T, DEFAULT&gt;::Grid(size_t inWidth, size_t inHeight):mWidth(inWidth), mHeight(inHeight)&#123;    initalizeCellsContainer();&#125;template&lt;typename T, const T&amp; DEFAULT&gt;void Grid&lt;T, DEFAULT&gt;::setElement(size_t x, size_t y, const T&amp; inElem)&#123;    mCells[x][y] = inElem;&#125;template&lt;typename T, const T&amp; DEFAULT&gt;T&amp; Grid&lt;T, DEFAULT&gt;::getElement(size_t x, size_t y)&#123;    return mCells[x][y];&#125;template&lt;typename T, const T&amp; DEFAULT&gt;const T&amp; Grid&lt;T, DEFAULT&gt;::getElement(size_t x, size_t y) const&#123;    return mCells[x][y];&#125;template&lt;typename T, const T&amp; DEFAULT&gt;void Grid&lt;T, DEFAULT&gt;::initalizeCellsContainer()&#123;    mCells.resize(mWidth);    for(auto&amp; col:mCells)&#123;        col.resize(mHeight);        for(auto&amp; elem:col)&#123;            elem = DEFAULT;        &#125;    &#125;&#125;/main/#include&lt;iostream&gt;#include&lt;vector&gt;#include&quot;girdElement.h&quot;#include&quot;SpreadsheetCell.h&quot;using namespace std;namespace&#123;    const int defaultInt = 11;    SpreadsheetCell defaultCell(1.2);&#125;// the second reference template must be const express, static inner or outter complete object// so add namespace for const default for saveint main()&#123;    // --------------- test default -----------------------//    // Grid&lt;int&gt; myDefaultGrid;    // Grid&lt;int, 10&gt; myDefaultGrid2;    // cout &lt;&lt; myDefaultGrid.getElement(0, 0) &lt;&lt; endl;    // cout &lt;&lt; myDefaultGrid2.getElement(0, 0) &lt;&lt; endl;    // error support: Grid(class, obj)    // ----------- test reference template ----------------//    Grid&lt;int, defaultInt&gt; myIntGrid;    cout &lt;&lt; myIntGrid.getElement(0, 0) &lt;&lt; endl;    Grid&lt;SpreadsheetCell, defaultCell&gt; mySpreadsheet;        return 0;&#125;</code></pre><p>分析3：多维Grid实现</p><pre><code>#pragma once#include&lt;vector&gt;template&lt;typename T, size_t N&gt;class NDGrid&#123;    public:        // constructor        explicit NDGrid(size_t inSize = kDefaultSize) &#123;resize(inSize);&#125;;                // operator        NDGrid&lt;T, N-1&gt;&amp; operator[](size_t x) &#123;return mElems[x];&#125;;        const NDGrid&lt;T, N-1&gt;&amp; operator[](size_t x) const &#123;return mElems[x];&#125;;        void resize(size_t newSize) &#123;mElems.resize(newSize);&#125;;        size_t getSize() const &#123;return mElems.size();&#125;;        static const size_t kDefaultSize = 10;    private:        std::vector&lt;NDGrid&lt;T, N-1&gt;&gt; mElems;&#125;;template&lt;typename T&gt;class NDGrid&lt;T, 1&gt;&#123;    public:        explicit NDGrid(size_t inSize = kDefaultSize) &#123;resize(inSize);&#125;;                // operator        T&amp; operator[](size_t x) &#123;return mElems[x];&#125;;        const T&amp; operator[](size_t x) const &#123;return mElems[x];&#125;;        void resize(size_t newSize) &#123;mElems.resize(newSize);&#125;;        size_t getSize() const &#123;return mElems.size();&#125;;        static const size_t kDefaultSize = 10;    private:        std::vector&lt;T&gt; mElems;&#125;; main /#include&lt;iostream&gt;#include&lt;vector&gt;#include&quot;nDGrid.h&quot;using namespace std;int main()&#123;    NDGrid&lt;int, 3&gt; threeDim(3);    threeDim[0][0][0] = 1;    return 0;&#125;</code></pre><p>分析4：变长参数控制与解析</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void handleValue(int value)&#123;    cout &lt;&lt; &quot;Interger: &quot; &lt;&lt; value &lt;&lt; endl;&#125;void handleValue(double value)&#123;    cout &lt;&lt; &quot;Double: &quot; &lt;&lt; value &lt;&lt; endl;&#125;void handleValue(const string&amp; value)&#123;    cout &lt;&lt; &quot;String: &quot; &lt;&lt; value &lt;&lt; endl;&#125;template&lt;typename T&gt;void processValue(T arg)&#123;    handleValue(arg);&#125;template&lt;typename T1, typename ... Tn&gt;void processValue(T1 arg1, Tn ... argn)&#123;    handleValue(arg1);    processValue(argn...);&#125;// non-const reference with std::forward() to imporve performencetemplate&lt;typename T&gt;void processValueII(T&amp;&amp; arg)&#123;    handleValue(std::forward&lt;T&gt;(arg));&#125;template&lt;typename T1, typename ... Tn&gt;void processValueII(T1 arg1, Tn ... argn)&#123;    handleValue(arg1);    processValueII(std::forward&lt;Tn&gt;(argn)...);&#125;int main()&#123;    processValue(1, 2, 3.56, &quot;test&quot;, 1.1f);    cout &lt;&lt; endl;    processValueII(1, 2, 3.56, &quot;test&quot;, 1.1f);    return 0;&#125;</code></pre><p>分析5：元组值输出 （元编程：在编译时完成计算，而不是运行时完成。由于元组是在编译时完成，因此可以通过模板类实现编译时遍历操作)</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;tuple&gt; using namespace std;template&lt;int n, typename TupleType&gt;class tuple_print_helper&#123;public:    tuple_print_helper(const TupleType&amp; t) &#123;        tuple_print_helper&lt;n - 1, TupleType&gt; tp(t);        cout &lt;&lt; get&lt;n - 1&gt;(t) &lt;&lt; endl;    &#125;&#125;;template&lt;typename TupleType&gt;class tuple_print_helper&lt;0, TupleType&gt;&#123;public:    tuple_print_helper(const TupleType&amp;) &#123; &#125;&#125;;template&lt;typename T&gt;void tuple_print(const T&amp; t)&#123;    tuple_print_helper&lt;tuple_size&lt;T&gt;::value, T&gt; tph(t);&#125;int main()&#123;    auto t1 = make_tuple(1, 2, 3.56, &quot;test&quot;, 1.1f);    tuple_print(t1);    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;题目要求：假设有一个Grid类，定义了一个网格的的大小（mWidth, mHeight），每个网格对于一个值（value）,这个值可能是int,double,string等类型；存储整个网格的数据结构可以是vector,可以</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OpenCV----简单目标提取和分割</title>
    <link href="http://example.com/2022/01/19/OpenCV----%E7%AE%80%E5%8D%95%E7%9B%AE%E6%A0%87%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E5%89%B2/"/>
    <id>http://example.com/2022/01/19/OpenCV----%E7%AE%80%E5%8D%95%E7%9B%AE%E6%A0%87%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E5%89%B2/</id>
    <published>2022-01-19T14:59:32.827Z</published>
    <updated>2022-01-19T15:01:36.558Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>题目要求：提取一张背景简单的图像中物体的信息，包括面积，质心等特征；考虑图像存在噪声，首先对图像进行预处理，然后使用分割算法，在图像中标注对应信息；可能的话考虑在一个窗口中显示图像处理过程结果；</p><blockquote><p>分析：<br>1）对图像降噪的基本流程包括：噪声消除、光消除、二值化；<br>2）常用的分割算法包括：轮廓检测findContours()和连通域分析connectedComponent()；<br>3）考虑设计多窗口类MWindow,支持初始化定义窗口大小、子窗口数量设计；<br>4）考虑到光消除算法可以提供背景图，也可以不提供背景图，分割算法可以之获取分割图像，可以获取连通域面积特征，也可以获取连通域质心或轮廓特征，因此设计支持命令行控制的CommandLineParser对象；</p></blockquote><p>代码实现：</p><ul><li><p>MWindow类设计：</p><p>  // mwindow.hpp<br>  /*<br>  @File          :mwindow.hpp<br>  @Description:  :multiwindow to displace multi images<br>  @Date          :2021/12/22 15:56:02<br>  @Author        :xieyin<br>  @version       :1.0<br>  */<br>  #pragma once</p><p>  #include<iostream><br>  #include<string><br>  #include<vector><br>  using namespace std;</vector></string></iostream></p><p>  #include&lt;opencv2/core.hpp&gt;<br>  #include&lt;opencv2/highgui.hpp&gt;<br>  using namespace cv;</p><p>  class MWindow{</p><pre><code>  public:      // consturtor      MWindow(string windowTitle, int rows, int cols, int flags);      // add image into canvas      int addImage(string title, Mat img, bool render = false);      // remove image from canvas      void removeImage(int pos);      // adjust all image size in canvas      void render();  private:      int mRows, mCols;      string mWindowTitle;      Mat mCanvas;      vector&lt;string&gt; mSubTitles;      vector&lt;Mat&gt; mSubImages;      </code></pre><p>  };</p><p>  MWindow::MWindow(string windowTitle, int rows, int cols, int flags):mWindowTitle(windowTitle), mRows(rows), mCols(cols){</p><pre><code>  /*  @description  : MWindow constructor  @param  :       windowTitle : whole window title      rows : sub window rows      cols : sub window cols      flags : namedWindow flags (eg, WINDOW_AUTOSIZE)  @Returns  :   */ // create canvas  namedWindow(mWindowTitle, flags);  mCanvas = Mat(700, 1500, CV_8UC3);  imshow(mWindowTitle, mCanvas);</code></pre><p>  }</p><p>  int MWindow::addImage(string title, Mat img, bool render){</p><pre><code>  /*  @description  : add title and image into canvas  @param  :       title : sub image title      img : image to be added      render : render(flag) whether need to adjust the image for canvas  @Returns  :       index : sub image index in total mRows * mCols  */  mSubTitles.push_back(title);  mSubImages.push_back(img);  if(render)&#123;      MWindow::render();  &#125;  return mSubImages.size() - 1;</code></pre><p>  }</p><p>  void MWindow::removeImage(int pos){</p><pre><code>  /*  @description  : remove image from canvas based on index  @param  :       pos : sub image index in total mRows * mCols  @Returns  :       None  */  mSubTitles.erase(mSubTitles.begin() + pos);  mSubImages.erase(mSubImages.begin() + pos);</code></pre><p>  }</p><p>  void MWindow::render(){</p><pre><code>  /*  @description  : fill title and image into canvas in suitable way  @param  :       None  @Returns  :      None   */  mCanvas.setTo(Scalar(20, 20, 20));  // get sub canvas size  int cellH = mCanvas.rows / mRows;  int cellW = mCanvas.cols / mCols;  int margin = 10;  // set total number of images to load  int numImgs = mSubImages.size() &gt; mRows * mCols ? mRows * mCols : mSubImages.size();  for(int i = 0; i &lt; numImgs; i++)&#123;      // get title      string title = mSubTitles[i];      // get sub canvas top left location      int cellX = (cellW) * ((i) % mCols);      int cellY = (cellH) * floor( (i) / (float) mCols);      Rect mask(cellX, cellY, cellW, cellH);      // set subcanvas size      rectangle(mCanvas, Rect(cellX, cellY, cellW, cellH), Scalar(200, 200, 200), 1);      Mat cell(mCanvas, mask);      Mat imgResz;      // get cell aspect      double cellAspect = (double) cellW / (double) cellH;      // get image      Mat img = mSubImages[i];      // get image aspect      double imgAspect = (double) img.cols / (double) img.cols;      double wAspect = (double) cellW / (double) img.cols;      double hAspect = (double) cellH / (double) img.rows;      // get suitable aspect and resize image      double aspect = cellAspect &lt; imgAspect ? wAspect : hAspect;      resize(img, imgResz, Size(0, 0), aspect, aspect);      // if gray image, convert to BGR      if(imgResz.channels() == 1)&#123;          cvtColor(imgResz, imgResz, COLOR_GRAY2BGR);      &#125;      Mat subCell(mCanvas, Rect(cellX, cellY, imgResz.cols, imgResz.rows));      imgResz.copyTo(subCell);      putText(cell, title, Point(20, 20), FONT_HERSHEY_SIMPLEX, 0.6, Scalar(255, 0, 0));  &#125;  // show total canvas  imshow(mWindowTitle, mCanvas);</code></pre><p>  }</p></li><li><p>主函数：</p><p>  /*<br>  @File          :main.cpp<br>  @Description:  :do connected component demo in a multi window<br>  @Date          :2021/12/22 15:56:53<br>  @Author        :xieyin<br>  @version       :1.0<br>  */<br>  #include<iostream><br>  #include<string><br>  #include<cmath><br>  #include<memory><br>  using namespace std;</memory></cmath></string></iostream></p><p>  #include&lt;opencv2/core/utility.hpp&gt;<br>  #include&lt;opencv2/highgui.hpp&gt;<br>  #include&lt;opencv2/imgproc.hpp&gt;<br>  using namespace cv;</p><p>  #include”mwindow.hpp”</p><p>  shared_ptr<MWindow> myWin;</MWindow></p><p>  Scalar randColor(RNG&amp; rng){</p><pre><code>  /*  @description  : genert randow color  @param  :       rng : random number generator object  @Returns  :       Sacalar() : BGR scalar  */  auto iColor = (unsigned)rng;  return Scalar(iColor&amp;255, (iColor &gt;&gt; 8)&amp;255, (iColor &gt;&gt; 16)&amp;255);</code></pre><p>  }</p><p>  Mat calLigthPattern(Mat img){</p><pre><code>  /*  @description  : get source image&#39;s light pattern   @param  :       img : source BGR image or Gray image  @Returns  :       pattern : the light pattern  */  Mat pattern;  blur(img, pattern, Size(img.cols / 3, img.cols / 3));  return pattern;</code></pre><p>  }</p><p>  Mat removeLight(Mat img, Mat pattern, int methodLight){</p><pre><code>  /*  @description  : remove light between img and pattern based on method light  @param  :       img : source BGR/Gray image      pattern : pattern BGR/Gray image      methodLight : choise options: 0 difference, 1 div  @Returns  :       aux : light removed BGR/Gray image  */  Mat aux;  if(methodLight == 1)&#123;      // div operation in float 32 format CV_32F      Mat img32, pattern32;      img.convertTo(img32, 5);      pattern.convertTo(pattern32, 5);      aux = 1.0 - (img32 / pattern32);      // covert to CV_8U and clip      aux.convertTo(aux, 0, 255);  &#125;  else&#123;      // difference      aux = pattern - img;  &#125;  return aux;</code></pre><p>  }</p><p>  void connectedComponents(Mat img_thr){</p><pre><code>  /*  @description  : opencv connnected components  @param  :       img : threshold image  @Returns  :       None  */ Mat labels; auto num_objs = connectedComponents(img_thr, labels); if(num_objs &lt; 2)&#123;     cout &lt;&lt; &quot;no object is detected. &quot; &lt;&lt; endl;     return ; &#125; Mat res = Mat::zeros(img_thr.rows, img_thr.cols, CV_8UC3); RNG rng(0xFFFFFFFF); for(auto i = 1; i &lt; num_objs; i++)&#123;     Mat mask = labels == i;     res.setTo(randColor(rng), mask); &#125;</code></pre><p>  //    imshow(“result”, res);</p><pre><code> myWin -&gt; addImage(&quot;result&quot;, res);</code></pre><p>  }</p><p>  void connectedComponentsWithStats(Mat img_thr){</p><pre><code>  /*  @description  : connnected components with stats  @param  :       img : threshold image  @Returns  :       None  */  Mat labels, stats, centroids;  auto num_objs = connectedComponentsWithStats(img_thr, labels, stats, centroids);  if(num_objs &lt; 2)&#123;     cout &lt;&lt; &quot;no object is detected. &quot; &lt;&lt; endl;     return ; &#125; Mat res = Mat::zeros(img_thr.rows, img_thr.cols, CV_8UC3); RNG rng(0xFFFFFFFF); for(auto i = 1; i &lt; num_objs; i++)&#123;     Mat mask = labels == i;     res.setTo(randColor(rng), mask);     stringstream ss;     ss &lt;&lt; &quot;area: &quot; &lt;&lt; stats.at&lt;int&gt;(i, CC_STAT_AREA);     // add text info     putText(res, ss.str(), centroids.at&lt;Point2d&gt;(i), FONT_HERSHEY_SIMPLEX, 0.3, Scalar(0, 255, 0)); &#125; myWin -&gt; addImage(&quot;result&quot;, res);</code></pre><p>  }</p><p>  void findContours(Mat img_thr){</p><pre><code>  /*  @description  : find contours and put text  @param  :       img : threshold image  @Returns  :       None  */  vector&lt;vector&lt;Point&gt;&gt; contours;  findContours(img_thr, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);  if(contours.size() == 0)&#123;      cout &lt;&lt; &quot;no contours are found .&quot; &lt;&lt; endl;      return;  &#125;  RNG rng(0xFFFFFFFF);  Mat res = Mat::zeros(img_thr.rows, img_thr.cols, CV_8UC3);  // calculate moments  vector&lt;Moments&gt; mu(contours.size());  for (int i = 0; i &lt; contours.size(); i++)  &#123;      mu[i] = moments(contours[i], false);  &#125;  // calculate centroids  vector&lt;Point2f&gt; mc(contours.size());  for (int i = 0; i &lt; contours.size(); i++)  &#123;      mc[i] = Point2d(mu[i].m10 / mu[i].m00, mu[i].m01 / mu[i].m00);  &#125;  for(auto i = 0; i &lt; contours.size(); i++)&#123;      drawContours(res, contours, i, randColor(rng));      putText(res, &quot;*&quot;, Point(mc[i].x, mc[i].y), FONT_HERSHEY_SIMPLEX, 0.4, Scalar(255, 0, 255), 1);  &#125;  myWin -&gt; addImage(&quot;result&quot;, res);</code></pre><p>  }</p><p>  const char* keys  = {</p><pre><code>  &quot;&#123;help h usage ? | | print this message&#125;&quot;  &quot;&#123;@image | | Image to process&#125;&quot;  &quot;&#123;@lightPattern | | Image light pattern applied to image&#125;&quot;  &quot;&#123;lightMethod | 1 | Method to remove image background, 0 diff, 1 div, 2 no light removal&#125;&quot;  &quot;&#123;segMethod | 2 | Method to segment: 1 connected components, 2 connected components with states, 3 find contours&#125;&quot;</code></pre><p>  };</p><p>  int main(int argc, const char** argv){</p><pre><code>  CommandLineParser parser(argc, argv, keys);  if(parser.has(&quot;help&quot;))&#123;      parser.printMessage();      return 0;  &#125;  // load source img and light pattern img, set light and segment method  String imgFile = parser.get&lt;String&gt;(0);  String lightPat = parser.get&lt;String&gt;(1);  auto methodLight = parser.get&lt;int&gt;(&quot;lightMethod&quot;);  auto methodSeg = parser.get&lt;int&gt;(&quot;segMethod&quot;);    // check commoand format  if(!parser.check())&#123;      parser.printErrors();      return 0;  &#125;    // read source image  Mat img = imread(imgFile, 0);  if(img.data == NULL)&#123;      cout &lt;&lt; &quot;Error load image file . &quot; &lt;&lt; endl;      return 0;  &#125;  myWin = make_shared&lt;MWindow&gt;(&quot;Main Window&quot;, 2, 3, WINDOW_AUTOSIZE);  // create denoise image and box_smooth img  Mat img_noise, img_box_smooth;  medianBlur(img, img_noise, 3);  blur(img, img_box_smooth, Size(3, 3));        // read light image  Mat imgLightPat = imread(lightPat, 0);  if(imgLightPat.data == NULL)&#123;      // use blur with large kernel to get light pattern      imgLightPat = calLigthPattern(img_noise);     &#125;  medianBlur(imgLightPat, imgLightPat, 3);  // for image without light pattern   Mat img_no_light;  img_noise.copyTo(img_no_light);  if(methodLight != 2)&#123;      img_no_light = removeLight(img_noise, imgLightPat, methodLight);  &#125;  Mat img_thread;  if(methodLight != 2)&#123;      threshold(img_no_light, img_thread, 30, 255, THRESH_BINARY);  &#125;else&#123;      threshold(img_no_light, img_thread, 140, 255, THRESH_BINARY_INV);  &#125;  // show image  myWin-&gt;addImage(&quot;Input&quot;, img);  myWin-&gt;addImage(&quot;Input without noise&quot;, img_noise);  myWin-&gt;addImage(&quot;light pattern&quot;, imgLightPat);  myWin-&gt;addImage(&quot;no light&quot;, img_no_light);  myWin-&gt;addImage(&quot;thread&quot;, img_thread);  // add result image  switch (methodSeg)&#123;  case 1:      connectedComponents(img_thread);      break;  case 2:      connectedComponentsWithStats(img_thread);      break;  case 3:      findContours(img_thread);  default:      break;  &#125;    myWin-&gt;render();  waitKey(0);  return 0;</code></pre><p>  }</p></li></ul><p>结果展示：</p><pre><code>./main -h     #命令行查看使用方法</code></pre><p><img src="https://img-blog.csdnimg.cn/aa5f78b77fc44a2eb0a83f1348e42846.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfMzcxNzIxODI=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><pre><code>./main ../data/test.pgm  -lightMethod=2 -segMethod=2 # 无需背景图片输入</code></pre><p><img src="https://img-blog.csdnimg.cn/556469f7858242e88299ca3e4820a949.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfMzcxNzIxODI=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><pre><code>./main ../data/test.pgm ../data/light.pgm -lightMethod=2 -segMethod=2 # 一张原始图像和一张背景图像进行分割</code></pre><p><img src="https://img-blog.csdnimg.cn/7321a1e2a85042d6b840dfe8f317096e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfMzcxNzIxODI=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><pre><code>./main ../data/test.pgm ../data/light.pgm -lightMethod=0 -segMethod=3 # 根据原始图像和背景图像进行轮廓和质心提取</code></pre><p><img src="https://img-blog.csdnimg.cn/0ad1a1ed25df4554b2518a9978a5f2bf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfMzcxNzIxODI=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;题目要求：提取一张背景简单的图像中物体的信息，包括面积，质心等特征；考虑图像存在噪声，首先对图像进行预处理，然后使用分割算法，在图像中标注对应信息；可能的话考虑在一个窗口中显示图像处理过程结果；&lt;/p&gt;
&lt;blockquot</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++高级编程----多线程编程</title>
    <link href="http://example.com/2022/01/19/C++%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2022/01/19/C++%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-19T14:59:32.587Z</published>
    <updated>2022-01-19T15:01:36.558Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>题目要求：1）假设有一个Counter类，包含一个id和计数次数mNumIters，支持多线程（互斥体）完成计数任务；2）设计一个发送者和消费者模式的数据传输模型；3）支持多线程加法运算，实现每个Counter自加后结果不变；4）考虑设计一个日志类，多线程读写数据，写入数据后存储到log.txt文件中。</p><blockquote><p>分析：<br>1）定义基于mutex的多线程任务，mutex支持lock_gurad和unique_lock等加锁方式，考虑重写类Counter的operator()，实现参数传递；<br>2）定义基于条件变量的多线程任务，condition_variable支持wait()和notify_all()/notify_one()等方法根据条件完成对已加锁的mutex的操作；<br>3）定义原子性counter,每个线程完成各自的加法运算值递增到counter中，保持数据同步；<br>4）Logger类需要考虑数据存储结构，此处定义为队列queue<string>，通过互斥体保护队列数据的访问，考虑到可能存在后台程序崩溃，需要设计相应的析构函数和对应的是否退出的原子性变量mExit<br>5) 标准库多线程的编译指令：g++ -Wall -pthread -g -o desApp source.cpp</string></p></blockquote><p>代码实现：<br>1：互斥体的基本方法</p><pre><code>/*************************************************************************   &gt; File Name: mutexDemo.cpp   &gt; Author: xxx   &gt; Mail: email@xx.com    &gt; Created Time: 2021年12月08日 星期三 15时51分30秒************************************************************************/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;climits&gt;#include&lt;mutex&gt;#include&lt;chrono&gt;#include&lt;thread&gt;using namespace std;class Counter&#123;   public:       Counter(int id, int numIters):mId(id), mNumIters(numIters)&#123;       &#125;       // lock_guard       /*       void operator()() const&#123;           for(int i = 0; i &lt; mNumIters; ++i)&#123;               lock_guard&lt;mutex&gt; lock(mMutex);               cout &lt;&lt; &quot;Counter &quot; &lt;&lt; mId &lt;&lt; &quot; has value &quot; &lt;&lt; i &lt;&lt; endl;           &#125;       &#125;*/       // unique_lock       void operator()() const&#123;           for(int i = 0; i &lt; mNumIters; ++i)&#123;               unique_lock&lt;timed_mutex&gt; lock(mTimeMutex, 200ms);               if(lock)&#123;                   cout &lt;&lt;&quot;Counter &quot; &lt;&lt; mId &lt;&lt; &quot; has value &quot; &lt;&lt; i &lt;&lt; endl;               &#125;               // else lock 200ms           &#125;       &#125;   private:       int mId;       int mNumIters;       // static mutex mMutex for lock_guard;       static timed_mutex mTimeMutex;&#125;;// mutex Counter::mMutex;timed_mutex Counter::mTimeMutex;int main()&#123;   thread t1&#123;Counter&#123;1, 30&#125;&#125;;   Counter c(2, 15);   thread t2(c);   thread t3(Counter(3, 10));   t1.join();   t2.join();   t3.join();   return 0;&#125;</code></pre><p>2、条件变量的使用方法(使用条件变量和互斥体的区别)</p><pre><code>/*************************************************************************    &gt; File Name: condVarDemo.cpp    &gt; Author: xxx    &gt; Mail: email@xx.com     &gt; Created Time: 2021年12月08日 星期三 16时14分09秒 ************************************************************************/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;climits&gt;#include&lt;thread&gt;#include&lt;mutex&gt;#include&lt;deque&gt;#include&lt;chrono&gt;#include&lt;condition_variable&gt;using namespace std;std::deque&lt;int&gt; q; // global queuestd::mutex mMutex; // global mutexstd::condition_variable mCondVar; //global condition variablevoid provider()&#123;    int count = 10;    while(count &gt; 0)&#123;        unique_lock&lt;mutex&gt; lock(mMutex);        q.push_front(count);        lock.unlock();        std::this_thread::sleep_for(std::chrono::seconds(1));        count--;    &#125;&#125;void consumer()&#123;    int data = 0;    while(data != 1)&#123;        unique_lock&lt;mutex&gt; lock(mMutex);        if(!q.empty())&#123;            data = q.back();            q.pop_back();            lock.unlock();            cout &lt;&lt; &quot;consumter get data from provider: &quot; &lt;&lt; data &lt;&lt; endl;        &#125;else&#123;            lock.unlock();            std::this_thread::sleep_for(std::chrono::milliseconds(500));        &#125;    &#125;&#125;void providerII()&#123;    int count = 10;    while(count &gt; 0)&#123;        unique_lock&lt;mutex&gt; lock(mMutex);        q.push_front(count);        lock.unlock();        // add condvar notification        mCondVar.notify_one();        std::this_thread::sleep_for(std::chrono::seconds(1));        count--;    &#125;&#125;void consumerII()&#123;    int data = 0;    while(data != 1)&#123;        unique_lock&lt;mutex&gt; lock(mMutex);        /*while(q.empty())&#123;    // note for multitime to check queue data            mCondVar.wait(lock);        &#125; for better understand, use next line to replace*/        mCondVar.wait(lock, []()&#123;return !q.empty();&#125;);        data = q.back();        q.pop_back();        lock.unlock();        cout &lt;&lt; &quot;consumer get data from provider: &quot; &lt;&lt; data &lt;&lt; endl;    &#125;&#125;int main()&#123;    thread t1(providerII);    thread t2(consumerII);    t1.join();    t2.join();    return 0;&#125;</code></pre><p>3：原子操作(线程中函数的传入是复制形式传入，转换为引用传入需要使用std::ref(var))</p><pre><code>/*************************************************************************    &gt; File Name: atomicDemo.cpp    &gt; Author: xxx    &gt; Mail: email@xx.com     &gt; Created Time: 2021年12月08日 星期三 14时40分34秒 ************************************************************************/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;climits&gt;#include&lt;thread&gt;#include&lt;atomic&gt;#include&lt;chrono&gt;using namespace std;void func(int&amp; counter)&#123;    for(int i = 0; i &lt; 100; ++i)&#123;        ++counter;        std::this_thread::sleep_for(std::chrono::milliseconds(1));    &#125;&#125;void funcII(std::atomic&lt;int&gt;&amp; counter)&#123;    int res = 0; // to improve performence    for(int i = 0; i &lt; 100; ++i)&#123;        ++res;        std::this_thread::sleep_for(std::chrono::milliseconds(1));    &#125;    counter += res;&#125;int main()&#123;    // int counter = 0;    std::atomic&lt;int&gt; counter(0);    std::vector&lt;std::thread&gt; threads;    for(int i = 0; i &lt; 10; ++i)&#123;        threads.push_back(std::thread&#123;funcII, std::ref(counter)&#125;);    &#125;    for(auto&amp; t : threads)&#123;        t.join();    &#125;    cout &lt;&lt; &quot;Result = &quot; &lt;&lt; counter &lt;&lt; endl;    return 0;&#125;</code></pre><p>4:Logger类实现方法</p><pre><code>//logger.h#ifndef LOGGER_H_#define LOGGER_H_#include&lt;queue&gt;#include&lt;thread&gt;#include&lt;string&gt;#include&lt;mutex&gt;#include&lt;condition_variable&gt;#include&lt;atomic&gt;class Logger&#123;    public:        Logger();        Logger(const Logger&amp; src) = delete;        Logger&amp; operator=(const Logger&amp; rhs) = delete;        void log(const std::string&amp; entry);        virtual ~Logger();    private:        std::atomic&lt;bool&gt; mExit;        // Mutex and condition variable to protect access to the queue        std::mutex mMutex;        std::condition_variable mCondVar;        std::queue&lt;std::string&gt; mQueue;        std::thread mThread;        void processEntries();&#125;;#endif//logger.cpp#include&lt;fstream&gt;#include&lt;iostream&gt;#include&quot;logger.h&quot;using namespace std;Logger::Logger(): mExit(false)&#123;    mThread = thread&#123;&amp;Logger::processEntries, this&#125;;&#125;Logger::~Logger()&#123;    &#123;        unique_lock&lt;mutex&gt; lock(mMutex);        mExit = true;        mCondVar.notify_all();    &#125;    mThread.join();&#125;void Logger::log(const std::string&amp; entry)&#123;    unique_lock&lt;mutex&gt; lock(mMutex);    mQueue.push(entry);    mCondVar.notify_all();&#125;void Logger::processEntries()&#123;    ofstream ofs(&quot;log.txt&quot;);    if(ofs.fail())&#123;        cout &lt;&lt; &quot;Fail to open logfile. &quot; &lt;&lt; endl;    &#125;    unique_lock&lt;mutex&gt; lock(mMutex);    while(true)&#123;        if(!mExit)&#123;            mCondVar.wait(lock);        &#125;        lock.unlock();        while(true)&#123;            lock.lock();            if(mQueue.empty())&#123;                break;            &#125;else&#123;                ofs &lt;&lt; mQueue.front() &lt;&lt; endl;                mQueue.pop();            &#125;            lock.unlock();        &#125;        if(mExit)&#123;            break;        &#125;    &#125;&#125;// main.cpp#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;thread&gt;#include&lt;vector&gt;#include&quot;logger.h&quot;using namespace std;void logSomeMessages(int id, Logger&amp; logger)&#123;    for(int i = 0; i &lt; 10; i++)&#123;        stringstream ss;        ss &lt;&lt; &quot;Log entry &quot; &lt;&lt; i &lt;&lt; &quot; from thread &quot; &lt;&lt; id;        logger.log(ss.str());    &#125;&#125;int main()&#123;    Logger logger;    vector&lt;thread&gt; threads;    for(int i = 0; i &lt; 10; i++)&#123;        threads.emplace_back(logSomeMessages, i, ref(logger));    &#125;    for(auto&amp; t : threads)&#123;        t.join();    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;题目要求：1）假设有一个Counter类，包含一个id和计数次数mNumIters，支持多线程（互斥体）完成计数任务；2）设计一个发送者和消费者模式的数据传输模型；3）支持多线程加法运算，实现每个Counter自加后结果不变</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OpenCV----YOLOv3目标检测模型推理</title>
    <link href="http://example.com/2022/01/19/OpenCV----YOLOv3%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86/"/>
    <id>http://example.com/2022/01/19/OpenCV----YOLOv3%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86/</id>
    <published>2022-01-19T14:59:32.451Z</published>
    <updated>2022-01-19T15:01:36.326Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>题目要求：了解opencv的DNN库，给定一张自然场景图片，使用训练好的yolov3模型，进行目标检测结果输出。</p><blockquote><p>分析：<br>1）opencv的DNN模块集成了很多深度学习模型，包括人脸检测、图像分类、分割、目标检测等，集成了Pytorch、tensorflow、paddlepaddle等模型框架（参看代码库<a href="https://github.com/opencv/opencv/tree/master/samples/dnn">OpenCV/dnn</a>）<br>2）深度学习推理模型一般步骤：加载模型，包括配置文件和权重文件；输入图像预处理，转换成模型可接受的文件类型和尺寸；模型预测后处理，对于目标检测，主要是NMS后处理方法；</p></blockquote><ul><li><p>结果展示：</p><p>  ./bin/yolov3Predict -h<br>  #######<br>  Usage: yolov3Predict [params] image confThreshold nmsThresshold </p><pre><code>      -?, -h, --help, --usage (value:true)              opecv based deep learining demo      image              Image to process      confThreshold (value:0.5)              confidence threshold, default 0.5      nmsThresshold (value:0.3)              nms threshold, default 0.3</code></pre><p>   ./bin/yolov3Predict data/test.jpg</p></li><li><p>  代码示例：</p></li></ul><p>yolov3Predict.cpp</p><pre><code>//yolov3Predict.cpp/*@File          :yolov3Predict.cpp@Description:  :@Date          :2022/1/9 20:02:10@Author        :@version       :1.0*/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;#include&lt;fstream&gt;#include&lt;vector&gt;using namespace std;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/core.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;opencv2/dnn.hpp&gt;using namespace cv;using namespace dnn;#include&quot;utils.hpp&quot;// define command parsebool parseParam(int argc, char** argv, const char* keys, Mat&amp; img, float&amp; confThreshold, float&amp; nmsThresshold)&#123;    /*    @description  : command parse function    @param  :         int argc : main argc        char** argv: main argv        keys : command parse keys        img : the image to read        confThreshold : confidence threshold setting        nmsThresshold : nms threshold setting    @Returns  :         (ref returns)    */    CommandLineParser parser(argc, argv, keys);    if(parser.has(&quot;help&quot;))&#123;        parser.printMessage();        return false;    &#125;    // check commoand format    if(!parser.check())&#123;        parser.printErrors();        return false;    &#125;    // get image    String imgFile = parser.get&lt;String&gt;(0);    img = imread(imgFile);    if(img.empty())&#123;        cout &lt;&lt; &quot;error to load test image. &quot; &lt;&lt; endl;        return false;    &#125;    // get confidence threshold    confThreshold = parser.get&lt;float&gt;(1);    // get nms threshold    nmsThresshold = parser.get&lt;float&gt;(2);    return true;&#125;int main(int argc, char** argv)&#123;    const char* keys  = &#123;        &quot;&#123;help h usage ? | | opecv based deep learining demo&#125;&quot;        &quot;&#123;@image | | Image to process&#125;&quot;        &quot;&#123;@confThreshold | 0.5 | confidence threshold, default 0.5&#125;&quot;        &quot;&#123;@nmsThresshold | 0.3 | nms threshold, default 0.3&#125;&quot;&#125;;    Mat img, blob;    float confThreshold, nmsThresshold;    // update data    if(!parseParam(argc, argv, keys, img, confThreshold, nmsThresshold))&#123;        return 0;    &#125;    // load model    string classFile = &quot;model/coco.names&quot;;    ifstream fin(classFile.c_str());    string line;    vector&lt;string&gt; classes;    while(getline(fin, line))&#123;        classes.push_back(line);    &#125;    string modelCfg = &quot;model/yolov3.cfg&quot;;    string modelWeg = &quot;model/yolov3.weights&quot;;    Net yolov3 = readNetFromDarknet(modelCfg, modelWeg);    yolov3.setPreferableBackend(DNN_BACKEND_OPENCV);    yolov3.setPreferableTarget(DNN_TARGET_CPU);    // convert image to blob format    blobFromImage(img, blob, 1/255.0, Size(416, 416), Scalar(0,0,0), true, false);    yolov3.setInput(blob);    vector&lt;Mat&gt; outputs;    // model predict    yolov3.forward(outputs, getoutputsName(yolov3));    // post process (nms)    postProcess(img, outputs, classes, confThreshold, nmsThresshold);        // time cost    vector&lt;double&gt; layersTime;    double freq = getTickFrequency() / 1000;    double t = yolov3.getPerfProfile(layersTime) / freq;    string label = format(&quot;time consuming: %.2f&quot;, t);    cout &lt;&lt; label &lt;&lt; endl;    imshow(&quot;input&quot;, img);    imwrite(&quot;output.jpg&quot;, img);    waitKey(0);    return 0;&#125;</code></pre><p>utils.cpp</p><pre><code>/*@File          :utils.cpp@Description:  :@Date          :2022/1/9 20:11:10@Author        :@version       :1.0*/#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;memory&gt;#include&lt;iostream&gt;using namespace std;#include&lt;opencv2/core/utility.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;opencv2/core.hpp&gt;#include&lt;opencv2/dnn.hpp&gt;using namespace cv;using namespace dnn;#include&quot;utils.hpp&quot;Scalar randColor(RNG&amp; rng)&#123;    /*    @description  : generate randow color    @param  :         rng : random number generator object    @Returns  :         Sacalar() : BGR scalar    */    auto iColor = (unsigned)rng;    return Scalar(iColor&amp;255, (iColor &gt;&gt; 8)&amp;255, (iColor &gt;&gt; 16)&amp;255);&#125;// get model output namevector&lt;string&gt; getoutputsName(Net&amp; net)&#123;    /*    @description  : get model outputs name    @param  :         Net : deep learning model    @Returns  :         names : model output names    */    static vector&lt;string&gt; names;    if(names.empty())&#123;        // get output layer idx        vector&lt;int&gt; outLayers = net.getUnconnectedOutLayers();        // get all namenames        vector&lt;string&gt; layersName = net.getLayerNames();        names.resize(outLayers.size());        for(size_t i = 0; i &lt; outLayers.size(); i++)&#123;            names[i] = layersName[outLayers[i] - 1];        &#125;    &#125;    return names;&#125;// draw prdict result on imagevoid drawPred(vector&lt;string&gt; classes, int classId, float conf, int left, int top, int right, int bottom, Mat&amp; frame)&#123;    /*    @description  : drop boxes and confidence on frame    @param  :         classes : the total classes list        classId : the predicted class id        conf : predicted confidence        left : left location        top : top locatioin        right : right location        bottom : bottom location        frame : the image to draw    @Returns  :         (ref return)    */    // draw rectanle for object detected    rectangle(frame, Point(left, top), Point(right, bottom), Scalar(255, 255, 255), 1);    // set rectangle for label show    string conf_label = format(&quot;%.2f&quot;, conf);    string label = &quot;&quot;;    if(!classes.empty())&#123;        label = classes[classId] + &quot; : &quot; + conf_label;    &#125;    int baseLine;    Size labelSize = getTextSize(label, FONT_HERSHEY_SIMPLEX, 0.5, 1, &amp;baseLine);    top = max(top, labelSize.height);    rectangle(frame, Point(left, top - labelSize.height), Point(left + labelSize.width, top+baseLine), Scalar(255, 255, 255), FILLED);    // put label text on image    putText(frame, label, Point(left, top), FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 0), 1, LINE_AA);&#125;// post process (NMS) for object detectionvoid postProcess(Mat&amp; frame, vector&lt;Mat&gt;&amp; outs, vector&lt;string&gt; classes, float confThreshold, float nmsThresshold)&#123;    /*    @description  : post process predict result to get suitable box to display    @param  :         frame : image to process and return        outs : predicts result        classes : the total classes list        confThreshold : confidence threshold setting        nmsThresshold : nms threshold setting    @Returns  :         (ref return)    */    // get classId, confidence and boxes    vector&lt;int&gt; classIds;    vector&lt;float&gt; confs;    vector&lt;Rect&gt; boxes;    for(size_t i = 0; i &lt; outs.size(); i++)&#123;        float* data = (float*) outs[i].data;        for(int j = 0; j &lt; outs[i].rows; j++, data += outs[i].cols)&#123;            // get socres for detectd class and scores            Mat scores = outs[i].row(j).colRange(5, outs[i].cols);            Point classIdPoint;            double conf;            // get min max value in socores with idx            minMaxLoc(scores, 0, &amp;conf, 0, &amp;classIdPoint);            // filter too small confidence            if(conf &gt; confThreshold)&#123;                int x = (int) (data[0]*frame.cols);                int y = (int) (data[1]*frame.rows);                int w = (int) (data[2]*frame.cols);                int h = (int) (data[3]*frame.rows);                int left = x - w / 2;                int top = y - h / 2;                classIds.push_back(classIdPoint.x);                confs.push_back((float)conf);                boxes.push_back(Rect(left, top, w, h));            &#125;        &#125;    &#125;    // NMS operation    vector&lt;int&gt; idxs;    NMSBoxes(boxes, confs, confThreshold, nmsThresshold, idxs);    for(size_t i = 0; i &lt; idxs.size(); i++)&#123;        int idx = idxs[i];        Rect box = boxes[idx];        drawPred(classes, classIds[idx], confs[idx], box.x, box.y, box.x+box.width, box.y+box.height, frame);    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;题目要求：了解opencv的DNN库，给定一张自然场景图片，使用训练好的yolov3模型，进行目标检测结果输出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分析：&lt;br&gt;1）opencv的DNN模块集成了很多深度学习模型，包括</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++高级编程----扩展STL</title>
    <link href="http://example.com/2022/01/19/C++%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B----%E6%89%A9%E5%B1%95STL/"/>
    <id>http://example.com/2022/01/19/C++%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B----%E6%89%A9%E5%B1%95STL/</id>
    <published>2022-01-19T14:59:32.243Z</published>
    <updated>2022-01-19T15:01:35.890Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>题目要求：编写一个遵循一般STL规则的基本容器hash_map，考虑类模板编程方式，支持多种数据格式。</p><blockquote><p>分析：<br>1）hash_map接口支持用户传入自定义的hash函数和hash桶的数目，在用户不知道的情况下提供默认的hash函数和桶数目；</p><p>2）数据结构分析：hash_map支持myHash[key] = value能在常数时间内完成，每一个key可能有一系列value，value由（key,value）组成，因此考虑数据结构为:vector&lt;list&lt;pair&lt;key, value&gt;&gt;&gt;;</p><p>3）hash函数定义hash算法，支持operator()，返回hash后的值（支持不同指针hash到同一值，考虑模板特例化）；<br>4) hash_map支持按key查询和删除，按（key, value）插入，支持operator[]；</p><p>5）考虑与STL名称空间分离，定义自己的namespace并考虑模板编程，实现方法声明和方法实现隔离(遵从Google C++编程规范，对于模板类编程使用.inl后缀实现隔离)；</p></blockquote><p>头文件定义：</p><pre><code>// hash_map.h#ifndef HASH_MAP_H_#define HASH_MAP_H_#include&lt;vector&gt;#include&lt;list&gt;#include&lt;string&gt;#include&lt;iostream&gt;namespace ProCpp&#123;    // part 1: define hash function    template&lt;typename T&gt;    class hash&#123;        public:            size_t operator() (const T&amp; key) const;    &#125;;    //template specialization    template&lt;&gt;    class hash&lt;std::string&gt;&#123;        public:            size_t operator() (const std::string&amp; key) const;    &#125;;    // part 2: define hash_map data struction and operation    template&lt;typename Key, typename T, typename Compare = std::equal_to&lt;Key&gt;, typename Hash = hash&lt;Key&gt;&gt;    class hash_map&#123;        public:            using key_type = Key;            using mapped_type = T;            using value_type = std::pair&lt;Key, T&gt;;                        // define constructor            explicit hash_map(const Compare&amp; comp = Compare(), size_t numBuckets = 101, const Hash&amp; hash = Hash());            // search operation            value_type* find(const key_type&amp; key);            const value_type* find(const key_type&amp; key) const;            // insert operation: insert (key, value) into hash map            void insert(const value_type&amp; value);            // erase operation: erase key from hash map            void erase(const key_type&amp; key);            // index operation: search (key, value) pair by key            T&amp; operator[] (const key_type&amp; key);        private:            using ListType = std::list&lt;value_type&gt;;            std::vector&lt;ListType&gt; mBuckets;            size_t mSize;            Compare mComp;            Hash mHash;            typename ListType::iterator findElement(const key_type&amp; key, size_t&amp; bucket);    &#125;;&#125;#include&quot;hash_map.inl&quot;#endif</code></pre><p>方法实现：</p><pre><code>// hash_map.inlnamespace ProCpp&#123;    // part 1: template hash class    // hash (key) -&gt; value    template&lt;typename T&gt;    size_t hash&lt;T&gt;::operator() (const T&amp; key) const&#123;        size_t res = 0;        size_t bytes = sizeof(key);        for(auto i = 0; i &lt; bytes; i++)&#123;            unsigned char b = *((unsigned char*)&amp;key + i);            res += b;        &#125;        return res;    &#125;    // template specialization: hash(string) -&gt; value    size_t hash&lt;std::string&gt;::operator() (const std::string&amp; key) const&#123;        size_t res = 0;        for(size_t i = 0; i &lt; key.size(); i++)&#123;            res += (unsigned char) key[i];        &#125;        return res;    &#125;    // part 2: hash map operation    // hash map constructor    template&lt;typename Key, typename T, typename Compare, typename Hash&gt;    hash_map&lt;Key, T, Compare, Hash&gt;::hash_map(const Compare&amp; comp, size_t numBuckets, const Hash&amp; hash):mSize(0), mComp(comp), mHash(hash)&#123;        if(numBuckets == 0)&#123;            throw std::invalid_argument(&quot;Number of buckets must be positve !&quot;);        &#125;        mBuckets.resize(numBuckets);    &#125;    template&lt;typename Key, typename T, typename Compare, typename Hash&gt;    typename hash_map&lt;Key, T, Compare, Hash&gt;::value_type* hash_map&lt;Key, T, Compare, Hash&gt;::find(const key_type&amp; key)&#123;        size_t bucket;        auto it = findElement(key, bucket);        if(it == mBuckets[bucket].end())&#123;            return nullptr;        &#125;        return &amp;(*it);    &#125;    template&lt;typename Key, typename T, typename Compare, typename Hash&gt;    const typename hash_map&lt;Key, T, Compare, Hash&gt;::value_type* hash_map&lt;Key, T, Compare, Hash&gt;::find(const key_type&amp; key) const&#123;        return const_cast&lt;hash_map&lt;Key, T, Compare, Hash&gt;*&gt; (this)-&gt;find(key);    &#125;    template&lt;typename Key, typename T, typename Compare, typename Hash&gt;    void hash_map&lt;Key, T, Compare, Hash&gt;::insert(const value_type&amp; value)&#123;        size_t bucket;        auto it = findElement(value.first, bucket);        if(it == mBuckets[bucket].end())&#123;            mBuckets[bucket].push_back(value);            mSize++;        &#125;    &#125;    template&lt;typename Key, typename T, typename Compare, typename Hash&gt;    void hash_map&lt;Key, T, Compare, Hash&gt;::erase(const key_type&amp; key)&#123;        size_t bucket;        auto it = findElement(key, bucket);        if(it != mBuckets[bucket].end())&#123;            mBuckets[bucket].erase(it);            mSize--;        &#125;    &#125;    template&lt;typename Key, typename T, typename Compare, typename Hash&gt;    T&amp; hash_map&lt;Key, T, Compare, Hash&gt;::operator[] (const key_type&amp; key)&#123;        size_t bucket;        auto it = find(key);        if(it == nullptr)&#123;            insert(std::make_pair(key, T()));            it = find(key);        &#125;        return it -&gt; second;    &#125;    template&lt;typename Key, typename T, typename Compare, typename Hash&gt;    typename hash_map&lt;Key, T, Compare, Hash&gt;::ListType::iterator hash_map&lt;Key, T, Compare, Hash&gt;::findElement(const key_type&amp; key, size_t&amp; bucket)&#123;        bucket = mHash(key) % mBuckets.size();        for(auto it = mBuckets[bucket].begin(); it != mBuckets[bucket].end(); ++it)&#123;            if(mComp(it -&gt; first, key))&#123;                return it;            &#125;        &#125;        return mBuckets[bucket].end();    &#125;&#125;</code></pre><p>测试案例：</p><pre><code>#include&lt;iostream&gt;#include &quot;hash_map.h&quot;using namespace std;using namespace ProCpp;int main()&#123;    hash_map&lt;int, int&gt; myHash;    myHash.insert(make_pair(4, 40));    myHash.insert(make_pair(4, 50));    myHash.insert(make_pair(6, 60));    int key = 4;    auto found = myHash.find(key);    if(found != nullptr)&#123;        cout &lt;&lt; &quot;find map (&quot; &lt;&lt; key &lt;&lt; &quot;, &quot; &lt;&lt; found -&gt; second &lt;&lt; &quot;)&quot;&lt;&lt; endl;    &#125;else&#123;        cout &lt;&lt; &quot;not found (key, value) pair &quot; &lt;&lt; endl;    &#125;    myHash[4] = 35;    myHash[4] = 60;      found = myHash.find(key);    if(found != nullptr)&#123;        cout &lt;&lt; &quot;find map (&quot; &lt;&lt; key &lt;&lt; &quot;, &quot; &lt;&lt; found -&gt; second &lt;&lt; &quot;)&quot;&lt;&lt; endl;    &#125;else&#123;        cout &lt;&lt; &quot;not found (key, value) pair &quot; &lt;&lt; endl;    &#125;    myHash.erase(key);    found = myHash.find(key);    if(found != nullptr)&#123;        cout &lt;&lt; &quot;find map (&quot; &lt;&lt; key &lt;&lt; &quot;, &quot; &lt;&lt; found -&gt; second &lt;&lt; &quot;)&quot;&lt;&lt; endl;    &#125;else&#123;        cout &lt;&lt; &quot;not found (key, value) pair &quot; &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;题目要求：编写一个遵循一般STL规则的基本容器hash_map，考虑类模板编程方式，支持多种数据格式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分析：&lt;br&gt;1）hash_map接口支持用户传入自定义的hash函数和hash</summary>
      
    
    
    
    
  </entry>
  
</feed>
