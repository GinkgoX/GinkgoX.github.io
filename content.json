{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"topics","date":"2022-01-13T13:36:53.642Z","updated":"2022-01-12T14:56:46.317Z","comments":true,"path":"2022/01/13/topics/","link":"","permalink":"http://example.com/2022/01/13/topics/","excerpt":"","text":"outlineOpenCV : OpenCV—-YOLOv3目标检测模型推理 OpenCV : OpenCV—-简单对象分类 OpenCV : OpenCV—-简单目标提取和分割 OpenCV : OpenCV—-GUI设计示例 OpenCV : Caffe配置与编译—–OpenCV-3.4.1配置及编译 OpenCV : TensorFlow实战10GoogleLeNet进阶（Python调用OpenCV库实现图像识别） VSCode : VSCode配置之Opencv4x终极奥义 VSCode : VSCode——C++编译环境极简配置方法（简单到没没朋友(^)/） VSCode : VSCode导入Torch后出现红色下划线警告 VSCode : VSCode中文输出乱码问题解决方法 C++ : C++高级编程—-剖析（profile） C++ : C++高级编程—-对象池实例 C++ : C++高级编程—-多线程编程 C++ : C++高级编程—-模板的高级特性 C++ : C++高级编程—-扩展STL C++ : VSCode——C++编译环境极简配置方法（简单到没没朋友(^)/） C++ : C++高级编程—-熟悉类和对象 C++ : 数据结构与算法分析-C++描述第10章算法设计技巧（回溯算法之公路收费点重建问题） C++ : 数据结构与算法分析-C++描述第10章算法设计技巧（随机化算法之跳跃表） C++ : 数据结构与算法分析-C++描述第10章算法设计技巧（动态规整之最优二叉搜索树） C++ : 数据结构与算法分析-C++描述第10章算法设计技巧（分治算法之最近点对问题） C++ : 数据结构与算法分析-C++描述第10章算法设计技巧（贪心算法之霍夫曼编码） C++ : 数据结构与算法分析-C++描述第9章图论算法（欧拉回路问题之Fleury算法） C++ : 数据结构与算法分析-C++描述第9章图论算法（最小生成树之Kruskal算法） C++ : 数据结构与算法分析-C++描述第9章图论算法（最小生成树之Prim算法） C++ : 数据结构与算法分析-C++描述第9章图论算法（字梯游戏之Dijkstra算法应用） C++ : 数据结构与算法分析-C++描述第9章图论算法（全局点最短路径问题之Floyd算法动态规整） C++ : 数据结构与算法分析-C++描述第9章图论算法（单源最短路径问题之Dijkstra算法邻接表实现） C++ : 数据结构与算法分析-C++描述第9章图论算法（有向图之广度优先搜索和深度优先探索） C++ : 数据结构与算法分析-C++描述第9章图论算法（无向图之广度优先搜索和深度优先探索） C++ : 数据结构与算法分析-C++描述第8章迷宫生成（不相交类的一个应用） C++ : 数据结构与算法分析-C++描述第8章不相交集类（disjointSet） C++ : 数据结构与算法分析-C++描述第7章桶排序（bucketSort） C++ : 数据结构与算法分析-C++描述第7章间接排序（indirectionSort） C++ : 数据结构与算法分析-C++描述第7章快速排序（quickSort） C++ : 数据结构与算法分析-C++描述第7章归并排序（mergeSort） C++ : 数据结构与算法分析-C++描述第7章堆排序（heapSort） C++ : 数据结构与算法分析-C++描述第7章谢尔排序（shellSort） C++ : 数据结构与算法分析-C++描述第7章插入排序（insertionSort） C++ : 数据结构与算法分析-C++描述第6章二项队列ADT（BinomialQueue） C++ : 数据结构与算法分析-C++描述第6章斜堆ADT（SkewHeap） C++ : 数据结构与算法分析-C++描述第6章左式堆ADT（LeftistHeap） C++ : 数据结构与算法分析-C++描述第6章优先队列ADT（最大堆和最小堆） C++ : 数据结构与算法分析-C++描述第6章优先队列ADT（二叉堆） C++ : 数据结构与算法分析-C++描述第5章散列ADT（开放定址法） C++ : 数据结构与算法分析-C++描述第5章散列ADT（分离链接法） C++ : 数据结构与算法分析-C++描述第4章红黑树（拓展） C++ : 数据结构与算法分析-C++描述第4章B树 C++ : 数据结构与算法分析-C++描述第4章伸展树（splay树） C++ : 数据结构与算法分析-C++描述第4章平衡二叉树（AVL树） C++ : 数据结构与算法分析-C++描述第4章二叉树ADT（二叉查找树） C++ : 约瑟夫环的两种常见解法：链表解法和递归解法（C++版） C++ : 数据结构与算法分析-C++描述第3章队列ADT（循环队列的两种实现） C++ : 数据结构与算法分析-C++描述第3章栈ADT（简单计算器设计） C++ : 数据结构与算法分析-C++描述第3章双向链表（通用模板类型/泛型编程） C++ : 数据结构与算法分析-C++描述第2章关于素数的前生今世 C++ : C++Primer第五版第十七章编程练习（输入、输出和文件） C++ : C++Primer第五版第十六章编程练习（string类、STL、算法） C++ : C++Primer第五版第十五章编程练习（友元类、异常、RTTI） C++ : C++Primer第五版第十四章编程练习（包含、私有继承、类模板、多重继承） C++ : C++Primer第五版第十三章编程练习节选（继承、多态、动态内存分配、抽象基类（ABC）） C++ : C++Primer第五版第十二章编程练习节选（动态内存、类） C++ : C++Primer第五版第十一章编程练习节选（构造函数、友元函数、操作符重载） C++ : C++primer第五版第十章编程练习拓展（链表） C++ : C++Primer第五版第九章编程练习节选（名称空间&amp;Linux下Makefile结构） C++ : C++Primer第五版第八章编程练习节选（函数重载与模板函数） C++ : C++Primer第五版第七章编程练习节选（函数指针数组） C++ : C++primer第五版编程练习第六章习题节选 C++ : C++Primer第五版第六章编程练习节选（数组运算） C++ : 《C++Primer第五版编程练习–第五章》 C++ : C++primer第五版第五章编程练习节选（结构运算） Leetcode : Leetcode前缀和问题集锦 Leetcode : Leetcode排列组合问题集锦 TensorFlow : FastAPI+TensorFlow1.14常见错误 TensorFlow : JupyterNotebook：本地（win10）访问、运行服务器（linux）虚拟环境Pytorch、TensorFlowetc. TensorFlow : 目标检测之FasterR-CNN—-TensorFlow（CPU） TensorFlow : TensorFlow实战13DenseNet神经网络（CVPR2017最佳论文） TensorFlow : TensorFlow实战12ResNet进阶（手势识别） TensorFlow : TensorFlow实战11ResNet神经网络（ILSVRC-2015champion） TensorFlow : TensorFlow实战10GoogleLeNet进阶（Python调用OpenCV库实现图像识别） TensorFlow : TensorFlow实战9GoogleLeNet神经网络（2014ILSVRC1stinError(Top-5)） TensorFlow : TensorFlow实战8VGGNet进阶（图像风格迁移） TensorFlow : TensorFlow实战7VGGNet神经网络（ILSVRC-2014classification2ndandlocation1st） TensorFlow : TensorFlow实战6AlexNet进阶（ImageNet识别） TensorFlow : TensorFlow实战5AlexNet神经网络（ILSVRC-2012冠军） TensorFlow : TensorFlow实战4进阶CNN–CIFAR-10数据集训练与测试 TensorFlow : TensorFlow实战3LeNet5神经网络(LeNet-5CNN) TensorFlow : TensorFlow实战1自编码器（Autoencoder） TensorFlow : TensorFlow实战2多层感知机（Multi-LayerPreceptonMLP） TensorFlow : 《TensorFlow实例–VGG》 TensorFlow : 《TensorFlow实例一MINIST手写字体识别》 TensorFlow : 《VGGinTensorFlowDemo》 TensorFlow : 《TensorFlow实例》 Pytorch : Ubuntu20.04+RTX3090(兼容RTX2080Ti)+Pytorch1.7配置方法 Pytorch : PytorchCAM特征可视化 Pytorch : Pytorch学习基础——损失函数 Pytorch : JupyterNotebook：本地（win10）访问、运行服务器（linux）虚拟环境Pytorch、TensorFlowetc. Pytorch : Pytorch实例—-NLP之文本分类 Pytorch : Pytorch实例—-DCGAN图像生成 Pytorch : MANFOLDTX2配置Pytorch1.x方法总结（Python3.5+CUDA9.0+Opencv3.4.1） Pytorch : Pytorch实例—-CAFAR10数据集分类（ShuffleNet） Pytorch : Pytorch实例—-CAFAR10数据集分类（ResNet） Pytorch : Pytorch实例—-CAFAR10数据集分类（VGG） Pytorch : Pytorch实例—-CAFAR10数据集分类（AlexNet） Pytorch : Pytorch学习基础——RNN从训练到测试 Pytorch : Pytorch学习基础——LeNet从训练到测试 Pytorch : Pytorch学习基础——CNN基本结构搭建 Pytorch : Pytorch学习基础——torch.squeeze()&amp;torch.unsqueeze() Pytorch : Pytorch学习基础——torch.DataLoader Ubuntu : Ubuntu20.04+VScode+go环境配置 Ubuntu : Ubuntu20.04+RTX3090(兼容RTX2080Ti)+Pytorch1.7配置方法 Ubuntu : Ubuntu16.04显卡驱动安装及CUDA10.2配置教程 Ubuntu : Ubuntu16.04系统安装U盘启动方法 Ubuntu : Ubuntu18.04SSH&amp;scp远程传输文件到服务器 Ubuntu : Ubuntu18.04Anaconda安装pydotplus和graphviz可视化工具 Ubuntu : Ubuntu18.04安装Octave（4.4.1） Ubuntu : 解决VMware虚拟机Ubuntu18.04无法上网问题！ Ubuntu : Ubuntu16.04安装arm-linux-gcc方法步骤 统计学习方法 : 统计学习方法——第11章条件随机场（CRF） 统计学习方法 : 统计学习方法——牛顿法和拟牛顿法 统计学习方法 : 统计学习方法——第10章隐马尔可夫模型（HMM） 统计学习方法 : 统计学习方法——第8章提升方法（AdaBoost+） 统计学习方法 : 统计学习方法——第6章logistics回归与最大熵模型 统计学习方法 : 统计学习方法——第5章决策树 统计学习方法 : 统计学习方法——第4章朴素贝叶斯法 统计学习方法 : 统计学习方法——第3章k近邻法 统计学习方法 : 统计学习方法——第2章感知机模型编程实现 统计学习方法 : 统计学习方法——第2章感知机模型 统计学习方法 : 统计学习方法——第1章统计学习方法概论 机器学习 : 机器学习实战之分类篇一朴素贝叶斯（从原理到简单词性检测） 机器学习 : 机器学习实战之分类篇一决策树（高级应用：配镜大师） 机器学习 : 机器学习实战之分类篇一决策树（从银行放贷到相亲的if-else） 机器学习 : 机器学习实战之分类篇一k-近邻算法（高级应用：手写数字识别） 机器学习 : 机器学习实战之分类篇一k-近邻算法（从电影分类到海伦约会）","categories":[],"tags":[]},{"title":"OpenCV----YOLOv3目标检测","slug":"opencv","date":"2022-01-10T12:50:21.000Z","updated":"2022-01-10T13:26:29.807Z","comments":true,"path":"2022/01/10/opencv/","link":"","permalink":"http://example.com/2022/01/10/opencv/","excerpt":"","text":"题目要求：了解opencv的DNN库，给定一张自然场景图片，使用训练好的yolov3模型，进行目标检测结果输出。 分析：1）opencv的DNN模块集成了很多深度学习模型，包括人脸检测、图像分类、分割、目标检测等，集成了Pytorch、tensorflow、paddlepaddle等模型框架（参看代码库OpenCV/dnn）2）深度学习推理模型一般步骤：加载模型，包括配置文件和权重文件；输入图像预处理，转换成模型可接受的文件类型和尺寸；模型预测后处理，对于目标检测，主要是NMS后处理方法； 结果展示： 12345678910111213./bin/yolov3Predict -h#######Usage: yolov3Predict [params] image confThreshold nmsThresshold -?, -h, --help, --usage (value:true) opecv based deep learining demo image Image to process confThreshold (value:0.5) confidence threshold, default 0.5 nmsThresshold (value:0.3) nms threshold, default 0.3 1./bin/yolov3Predict data/test.jpg 代码示例： yolov3Predict.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//yolov3Predict.cpp/*@File :yolov3Predict.cpp@Description: :@Date :2022/1/9 20:02:10@Author :@version :1.0*/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;#include&lt;fstream&gt;#include&lt;vector&gt;using namespace std;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/core.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;opencv2/dnn.hpp&gt;using namespace cv;using namespace dnn;#include&quot;utils.hpp&quot;// define command parsebool parseParam(int argc, char** argv, const char* keys, Mat&amp; img, float&amp; confThreshold, float&amp; nmsThresshold)&#123; /* @description : command parse function @param : int argc : main argc char** argv: main argv keys : command parse keys img : the image to read confThreshold : confidence threshold setting nmsThresshold : nms threshold setting @Returns : (ref returns) */ CommandLineParser parser(argc, argv, keys); if(parser.has(&quot;help&quot;))&#123; parser.printMessage(); return false; &#125; // check commoand format if(!parser.check())&#123; parser.printErrors(); return false; &#125; // get image String imgFile = parser.get&lt;String&gt;(0); img = imread(imgFile); if(img.empty())&#123; cout &lt;&lt; &quot;error to load test image. &quot; &lt;&lt; endl; return false; &#125; // get confidence threshold confThreshold = parser.get&lt;float&gt;(1); // get nms threshold nmsThresshold = parser.get&lt;float&gt;(2); return true;&#125;int main(int argc, char** argv)&#123; const char* keys = &#123; &quot;&#123;help h usage ? | | opecv based deep learining demo&#125;&quot; &quot;&#123;@image | | Image to process&#125;&quot; &quot;&#123;@confThreshold | 0.5 | confidence threshold, default 0.5&#125;&quot; &quot;&#123;@nmsThresshold | 0.3 | nms threshold, default 0.3&#125;&quot;&#125;; Mat img, blob; float confThreshold, nmsThresshold; // update data if(!parseParam(argc, argv, keys, img, confThreshold, nmsThresshold))&#123; return 0; &#125; // load model string classFile = &quot;model/coco.names&quot;; ifstream fin(classFile.c_str()); string line; vector&lt;string&gt; classes; while(getline(fin, line))&#123; classes.push_back(line); &#125; string modelCfg = &quot;model/yolov3.cfg&quot;; string modelWeg = &quot;model/yolov3.weights&quot;; Net yolov3 = readNetFromDarknet(modelCfg, modelWeg); yolov3.setPreferableBackend(DNN_BACKEND_OPENCV); yolov3.setPreferableTarget(DNN_TARGET_CPU); // convert image to blob format blobFromImage(img, blob, 1/255.0, Size(416, 416), Scalar(0,0,0), true, false); yolov3.setInput(blob); vector&lt;Mat&gt; outputs; // model predict yolov3.forward(outputs, getoutputsName(yolov3)); // post process (nms) postProcess(img, outputs, classes, confThreshold, nmsThresshold); // time cost vector&lt;double&gt; layersTime; double freq = getTickFrequency() / 1000; double t = yolov3.getPerfProfile(layersTime) / freq; string label = format(&quot;time consuming: %.2f&quot;, t); cout &lt;&lt; label &lt;&lt; endl; imshow(&quot;input&quot;, img); imwrite(&quot;output.jpg&quot;, img); waitKey(0); return 0;&#125; utils.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/*@File :utils.cpp@Description: :@Date :2022/1/9 20:11:10@Author :@version :1.0*/#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;memory&gt;#include&lt;iostream&gt;using namespace std;#include&lt;opencv2/core/utility.hpp&gt;#include&lt;opencv2/highgui.hpp&gt;#include&lt;opencv2/imgproc.hpp&gt;#include&lt;opencv2/core.hpp&gt;#include&lt;opencv2/dnn.hpp&gt;using namespace cv;using namespace dnn;#include&quot;utils.hpp&quot;Scalar randColor(RNG&amp; rng)&#123; /* @description : generate randow color @param : rng : random number generator object @Returns : Sacalar() : BGR scalar */ auto iColor = (unsigned)rng; return Scalar(iColor&amp;255, (iColor &gt;&gt; 8)&amp;255, (iColor &gt;&gt; 16)&amp;255);&#125;// get model output namevector&lt;string&gt; getoutputsName(Net&amp; net)&#123; /* @description : get model outputs name @param : Net : deep learning model @Returns : names : model output names */ static vector&lt;string&gt; names; if(names.empty())&#123; // get output layer idx vector&lt;int&gt; outLayers = net.getUnconnectedOutLayers(); // get all namenames vector&lt;string&gt; layersName = net.getLayerNames(); names.resize(outLayers.size()); for(size_t i = 0; i &lt; outLayers.size(); i++)&#123; names[i] = layersName[outLayers[i] - 1]; &#125; &#125; return names;&#125;// draw prdict result on imagevoid drawPred(vector&lt;string&gt; classes, int classId, float conf, int left, int top, int right, int bottom, Mat&amp; frame)&#123; /* @description : drop boxes and confidence on frame @param : classes : the total classes list classId : the predicted class id conf : predicted confidence left : left location top : top locatioin right : right location bottom : bottom location frame : the image to draw @Returns : (ref return) */ // draw rectanle for object detected rectangle(frame, Point(left, top), Point(right, bottom), Scalar(255, 255, 255), 1); // set rectangle for label show string conf_label = format(&quot;%.2f&quot;, conf); string label = &quot;&quot;; if(!classes.empty())&#123; label = classes[classId] + &quot; : &quot; + conf_label; &#125; int baseLine; Size labelSize = getTextSize(label, FONT_HERSHEY_SIMPLEX, 0.5, 1, &amp;baseLine); top = max(top, labelSize.height); rectangle(frame, Point(left, top - labelSize.height), Point(left + labelSize.width, top+baseLine), Scalar(255, 255, 255), FILLED); // put label text on image putText(frame, label, Point(left, top), FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 0), 1, LINE_AA);&#125;// post process (NMS) for object detectionvoid postProcess(Mat&amp; frame, vector&lt;Mat&gt;&amp; outs, vector&lt;string&gt; classes, float confThreshold, float nmsThresshold)&#123; /* @description : post process predict result to get suitable box to display @param : frame : image to process and return outs : predicts result classes : the total classes list confThreshold : confidence threshold setting nmsThresshold : nms threshold setting @Returns : (ref return) */ // get classId, confidence and boxes vector&lt;int&gt; classIds; vector&lt;float&gt; confs; vector&lt;Rect&gt; boxes; for(size_t i = 0; i &lt; outs.size(); i++)&#123; float* data = (float*) outs[i].data; for(int j = 0; j &lt; outs[i].rows; j++, data += outs[i].cols)&#123; // get socres for detectd class and scores Mat scores = outs[i].row(j).colRange(5, outs[i].cols); Point classIdPoint; double conf; // get min max value in socores with idx minMaxLoc(scores, 0, &amp;conf, 0, &amp;classIdPoint); // filter too small confidence if(conf &gt; confThreshold)&#123; int x = (int) (data[0]*frame.cols); int y = (int) (data[1]*frame.rows); int w = (int) (data[2]*frame.cols); int h = (int) (data[3]*frame.rows); int left = x - w / 2; int top = y - h / 2; classIds.push_back(classIdPoint.x); confs.push_back((float)conf); boxes.push_back(Rect(left, top, w, h)); &#125; &#125; &#125; // NMS operation vector&lt;int&gt; idxs; NMSBoxes(boxes, confs, confThreshold, nmsThresshold, idxs); for(size_t i = 0; i &lt; idxs.size(); i++)&#123; int idx = idxs[i]; Rect box = boxes[idx]; drawPred(classes, classIds[idx], confs[idx], box.x, box.y, box.x+box.width, box.y+box.height, frame); &#125;&#125;","categories":[],"tags":[{"name":"opencv","slug":"opencv","permalink":"http://example.com/tags/opencv/"},{"name":"dnn","slug":"dnn","permalink":"http://example.com/tags/dnn/"},{"name":"yolov3","slug":"yolov3","permalink":"http://example.com/tags/yolov3/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-01-09T23:48:43.563Z","updated":"2022-01-10T12:48:33.524Z","comments":true,"path":"2022/01/10/hello-world/","link":"","permalink":"http://example.com/2022/01/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment command1234$ hexo clean$ hexo g$ hexo d$ hexo server","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"opencv","slug":"opencv","permalink":"http://example.com/tags/opencv/"},{"name":"dnn","slug":"dnn","permalink":"http://example.com/tags/dnn/"},{"name":"yolov3","slug":"yolov3","permalink":"http://example.com/tags/yolov3/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]}